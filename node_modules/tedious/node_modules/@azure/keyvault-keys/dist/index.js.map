{"version":3,"file":"index.js","sources":["../src/log.ts","../src/generated/models/index.ts","../src/generated/models/mappers.ts","../src/generated/models/parameters.ts","../src/generated/keyVaultClient.ts","../src/constants.ts","../../keyvault-common/src/parseWWWAuthenticate.ts","../../keyvault-common/src/challengeBasedAuthenticationPolicy.ts","../../keyvault-common/src/parseKeyVaultIdentifier.ts","../src/tracing.ts","../src/identifier.ts","../src/transformations.ts","../src/lro/keyVaultKeyPoller.ts","../src/lro/delete/operation.ts","../src/lro/delete/poller.ts","../src/lro/recover/operation.ts","../src/lro/recover/poller.ts","../src/keysModels.ts","../src/cryptography/crypto.ts","../src/cryptography/remoteCryptographyProvider.ts","../src/cryptography/conversions.ts","../src/cryptography/models.ts","../src/cryptography/rsaCryptographyProvider.ts","../src/cryptography/aesCryptographyProvider.ts","../src/cryptographyClient.ts","../src/cryptographyClientModels.ts","../src/index.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { createClientLogger } from \"@azure/logger\";\n\n/**\n * The \\@azure/logger configuration for this package.\n */\nexport const logger = createClientLogger(\"keyvault-keys\");\n","/*\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT License.\n *\n * Code generated by Microsoft (R) AutoRest Code Generator.\n * Changes may cause incorrect behavior and will be lost if the code is regenerated.\n */\n\nimport * as coreClient from \"@azure/core-client\";\nimport * as coreHttpCompat from \"@azure/core-http-compat\";\n\n/** The key create parameters. */\nexport interface KeyCreateParameters {\n  /** The type of key to create. For valid values, see JsonWebKeyType. */\n  kty: JsonWebKeyType;\n  /** The key size in bits. For example: 2048, 3072, or 4096 for RSA. */\n  keySize?: number;\n  /** The public exponent for a RSA key. */\n  publicExponent?: number;\n  keyOps?: JsonWebKeyOperation[];\n  /** The attributes of a key managed by the key vault service. */\n  keyAttributes?: KeyAttributes;\n  /** Application specific metadata in the form of key-value pairs. */\n  tags?: { [propertyName: string]: string };\n  /** Elliptic curve name. For valid values, see JsonWebKeyCurveName. */\n  curve?: JsonWebKeyCurveName;\n  /** The policy rules under which the key can be exported. */\n  releasePolicy?: KeyReleasePolicy;\n}\n\n/** The object attributes managed by the KeyVault service. */\nexport interface Attributes {\n  /** Determines whether the object is enabled. */\n  enabled?: boolean;\n  /** Not before date in UTC. */\n  notBefore?: Date;\n  /** Expiry date in UTC. */\n  expires?: Date;\n  /**\n   * Creation time in UTC.\n   * NOTE: This property will not be serialized. It can only be populated by the server.\n   */\n  readonly created?: Date;\n  /**\n   * Last updated time in UTC.\n   * NOTE: This property will not be serialized. It can only be populated by the server.\n   */\n  readonly updated?: Date;\n}\n\n/** The policy rules under which the key can be exported. */\nexport interface KeyReleasePolicy {\n  /** Content type and version of key release policy */\n  contentType?: string;\n  /** Defines the mutability state of the policy. Once marked immutable, this flag cannot be reset and the policy cannot be changed under any circumstances. */\n  immutable?: boolean;\n  /** Blob encoding the policy rules under which the key can be released. Blob must be base64 URL encoded. */\n  encodedPolicy?: Uint8Array;\n}\n\n/** A KeyBundle consisting of a WebKey plus its attributes. */\nexport interface KeyBundle {\n  /** The Json web key. */\n  key?: JsonWebKey;\n  /** The key management attributes. */\n  attributes?: KeyAttributes;\n  /** Application specific metadata in the form of key-value pairs. */\n  tags?: { [propertyName: string]: string };\n  /**\n   * True if the key's lifetime is managed by key vault. If this is a key backing a certificate, then managed will be true.\n   * NOTE: This property will not be serialized. It can only be populated by the server.\n   */\n  readonly managed?: boolean;\n  /** The policy rules under which the key can be exported. */\n  releasePolicy?: KeyReleasePolicy;\n}\n\n/** As of http://tools.ietf.org/html/draft-ietf-jose-json-web-key-18 */\nexport interface JsonWebKey {\n  /** Key identifier. */\n  kid?: string;\n  /** JsonWebKey Key Type (kty), as defined in https://tools.ietf.org/html/draft-ietf-jose-json-web-algorithms-40. */\n  kty?: JsonWebKeyType;\n  keyOps?: string[];\n  /** RSA modulus. */\n  n?: Uint8Array;\n  /** RSA public exponent. */\n  e?: Uint8Array;\n  /** RSA private exponent, or the D component of an EC private key. */\n  d?: Uint8Array;\n  /** RSA private key parameter. */\n  dp?: Uint8Array;\n  /** RSA private key parameter. */\n  dq?: Uint8Array;\n  /** RSA private key parameter. */\n  qi?: Uint8Array;\n  /** RSA secret prime. */\n  p?: Uint8Array;\n  /** RSA secret prime, with p < q. */\n  q?: Uint8Array;\n  /** Symmetric key. */\n  k?: Uint8Array;\n  /** Protected Key, used with 'Bring Your Own Key'. */\n  t?: Uint8Array;\n  /** Elliptic curve name. For valid values, see JsonWebKeyCurveName. */\n  crv?: JsonWebKeyCurveName;\n  /** X component of an EC public key. */\n  x?: Uint8Array;\n  /** Y component of an EC public key. */\n  y?: Uint8Array;\n}\n\n/** The key vault error exception. */\nexport interface KeyVaultError {\n  /**\n   * The key vault server error.\n   * NOTE: This property will not be serialized. It can only be populated by the server.\n   */\n  readonly error?: ErrorModel;\n}\n\n/** The key vault server error. */\nexport interface ErrorModel {\n  /**\n   * The error code.\n   * NOTE: This property will not be serialized. It can only be populated by the server.\n   */\n  readonly code?: string;\n  /**\n   * The error message.\n   * NOTE: This property will not be serialized. It can only be populated by the server.\n   */\n  readonly message?: string;\n  /**\n   * The key vault server error.\n   * NOTE: This property will not be serialized. It can only be populated by the server.\n   */\n  readonly innerError?: ErrorModel;\n}\n\n/** The key import parameters. */\nexport interface KeyImportParameters {\n  /** Whether to import as a hardware key (HSM) or software key. */\n  hsm?: boolean;\n  /** The Json web key */\n  key: JsonWebKey;\n  /** The key management attributes. */\n  keyAttributes?: KeyAttributes;\n  /** Application specific metadata in the form of key-value pairs. */\n  tags?: { [propertyName: string]: string };\n  /** The policy rules under which the key can be exported. */\n  releasePolicy?: KeyReleasePolicy;\n}\n\n/** The key update parameters. */\nexport interface KeyUpdateParameters {\n  /** Json web key operations. For more information on possible key operations, see JsonWebKeyOperation. */\n  keyOps?: JsonWebKeyOperation[];\n  /** The attributes of a key managed by the key vault service. */\n  keyAttributes?: KeyAttributes;\n  /** Application specific metadata in the form of key-value pairs. */\n  tags?: { [propertyName: string]: string };\n  /** The policy rules under which the key can be exported. */\n  releasePolicy?: KeyReleasePolicy;\n}\n\n/** The key list result. */\nexport interface KeyListResult {\n  /**\n   * A response message containing a list of keys in the key vault along with a link to the next page of keys.\n   * NOTE: This property will not be serialized. It can only be populated by the server.\n   */\n  readonly value?: KeyItem[];\n  /**\n   * The URL to get the next set of keys.\n   * NOTE: This property will not be serialized. It can only be populated by the server.\n   */\n  readonly nextLink?: string;\n}\n\n/** The key item containing key metadata. */\nexport interface KeyItem {\n  /** Key identifier. */\n  kid?: string;\n  /** The key management attributes. */\n  attributes?: KeyAttributes;\n  /** Application specific metadata in the form of key-value pairs. */\n  tags?: { [propertyName: string]: string };\n  /**\n   * True if the key's lifetime is managed by key vault. If this is a key backing a certificate, then managed will be true.\n   * NOTE: This property will not be serialized. It can only be populated by the server.\n   */\n  readonly managed?: boolean;\n}\n\n/** The backup key result, containing the backup blob. */\nexport interface BackupKeyResult {\n  /**\n   * The backup blob containing the backed up key.\n   * NOTE: This property will not be serialized. It can only be populated by the server.\n   */\n  readonly value?: Uint8Array;\n}\n\n/** The key restore parameters. */\nexport interface KeyRestoreParameters {\n  /** The backup blob associated with a key bundle. */\n  keyBundleBackup: Uint8Array;\n}\n\n/** The key operations parameters. */\nexport interface KeyOperationsParameters {\n  /** algorithm identifier */\n  algorithm: JsonWebKeyEncryptionAlgorithm;\n  value: Uint8Array;\n  /** Cryptographically random, non-repeating initialization vector for symmetric algorithms. */\n  iv?: Uint8Array;\n  /** Additional data to authenticate but not encrypt/decrypt when using authenticated crypto algorithms. */\n  additionalAuthenticatedData?: Uint8Array;\n  /** The tag to authenticate when performing decryption with an authenticated algorithm. */\n  authenticationTag?: Uint8Array;\n}\n\n/** The key operation result. */\nexport interface KeyOperationResult {\n  /**\n   * Key identifier\n   * NOTE: This property will not be serialized. It can only be populated by the server.\n   */\n  readonly kid?: string;\n  /** NOTE: This property will not be serialized. It can only be populated by the server. */\n  readonly result?: Uint8Array;\n  /** NOTE: This property will not be serialized. It can only be populated by the server. */\n  readonly iv?: Uint8Array;\n  /** NOTE: This property will not be serialized. It can only be populated by the server. */\n  readonly authenticationTag?: Uint8Array;\n  /** NOTE: This property will not be serialized. It can only be populated by the server. */\n  readonly additionalAuthenticatedData?: Uint8Array;\n}\n\n/** The key operations parameters. */\nexport interface KeySignParameters {\n  /** The signing/verification algorithm identifier. For more information on possible algorithm types, see JsonWebKeySignatureAlgorithm. */\n  algorithm: JsonWebKeySignatureAlgorithm;\n  value: Uint8Array;\n}\n\n/** The key verify parameters. */\nexport interface KeyVerifyParameters {\n  /** The signing/verification algorithm. For more information on possible algorithm types, see JsonWebKeySignatureAlgorithm. */\n  algorithm: JsonWebKeySignatureAlgorithm;\n  /** The digest used for signing. */\n  digest: Uint8Array;\n  /** The signature to be verified. */\n  signature: Uint8Array;\n}\n\n/** The key verify result. */\nexport interface KeyVerifyResult {\n  /**\n   * True if the signature is verified, otherwise false.\n   * NOTE: This property will not be serialized. It can only be populated by the server.\n   */\n  readonly value?: boolean;\n}\n\n/** The release key parameters. */\nexport interface KeyReleaseParameters {\n  /** The attestation assertion for the target of the key release. */\n  targetAttestationToken: string;\n  /** A client provided nonce for freshness. */\n  nonce?: string;\n  /** The encryption algorithm to use to protected the exported key material */\n  enc?: KeyEncryptionAlgorithm;\n}\n\n/** The release result, containing the released key. */\nexport interface KeyReleaseResult {\n  /**\n   * A signed object containing the released key.\n   * NOTE: This property will not be serialized. It can only be populated by the server.\n   */\n  readonly value?: string;\n}\n\n/** A list of keys that have been deleted in this vault. */\nexport interface DeletedKeyListResult {\n  /**\n   * A response message containing a list of deleted keys in the vault along with a link to the next page of deleted keys\n   * NOTE: This property will not be serialized. It can only be populated by the server.\n   */\n  readonly value?: DeletedKeyItem[];\n  /**\n   * The URL to get the next set of deleted keys.\n   * NOTE: This property will not be serialized. It can only be populated by the server.\n   */\n  readonly nextLink?: string;\n}\n\n/** Management policy for a key. */\nexport interface KeyRotationPolicy {\n  /**\n   * The key policy id.\n   * NOTE: This property will not be serialized. It can only be populated by the server.\n   */\n  readonly id?: string;\n  /** Actions that will be performed by Key Vault over the lifetime of a key. For preview, lifetimeActions can only have two items at maximum: one for rotate, one for notify. Notification time would be default to 30 days before expiry and it is not configurable. */\n  lifetimeActions?: LifetimeActions[];\n  /** The key rotation policy attributes. */\n  attributes?: KeyRotationPolicyAttributes;\n}\n\n/** Action and its trigger that will be performed by Key Vault over the lifetime of a key. */\nexport interface LifetimeActions {\n  /** The condition that will execute the action. */\n  trigger?: LifetimeActionsTrigger;\n  /** The action that will be executed. */\n  action?: LifetimeActionsType;\n}\n\n/** A condition to be satisfied for an action to be executed. */\nexport interface LifetimeActionsTrigger {\n  /** Time after creation to attempt to rotate. It only applies to rotate. It will be in ISO 8601 duration format. Example: 90 days : \"P90D\"  */\n  timeAfterCreate?: string;\n  /** Time before expiry to attempt to rotate or notify. It will be in ISO 8601 duration format. Example: 90 days : \"P90D\" */\n  timeBeforeExpiry?: string;\n}\n\n/** The action that will be executed. */\nexport interface LifetimeActionsType {\n  /** The type of the action. */\n  type?: ActionType;\n}\n\n/** The key rotation policy attributes. */\nexport interface KeyRotationPolicyAttributes {\n  /** The expiryTime will be applied on the new key version. It should be at least 28 days. It will be in ISO 8601 Format. Examples: 90 days: P90D, 3 months: P3M, 48 hours: PT48H, 1 year and 10 days: P1Y10D */\n  expiryTime?: string;\n  /**\n   * The key rotation policy created time in UTC.\n   * NOTE: This property will not be serialized. It can only be populated by the server.\n   */\n  readonly created?: Date;\n  /**\n   * The key rotation policy's last updated time in UTC.\n   * NOTE: This property will not be serialized. It can only be populated by the server.\n   */\n  readonly updated?: Date;\n}\n\n/** The get random bytes request object. */\nexport interface GetRandomBytesRequest {\n  /** The requested number of random bytes. */\n  count: number;\n}\n\n/** The get random bytes response object containing the bytes. */\nexport interface RandomBytes {\n  /** The bytes encoded as a base64url string. */\n  value: Uint8Array;\n}\n\n/** Properties of the key pair backing a certificate. */\nexport interface KeyProperties {\n  /** Indicates if the private key can be exported. Release policy must be provided when creating the first version of an exportable key. */\n  exportable?: boolean;\n  /** The type of key pair to be used for the certificate. */\n  keyType?: JsonWebKeyType;\n  /** The key size in bits. For example: 2048, 3072, or 4096 for RSA. */\n  keySize?: number;\n  /** Indicates if the same key pair will be used on certificate renewal. */\n  reuseKey?: boolean;\n  /** Elliptic curve name. For valid values, see JsonWebKeyCurveName. */\n  curve?: JsonWebKeyCurveName;\n}\n\n/** The export key parameters. */\nexport interface KeyExportParameters {\n  /** The export key encryption Json web key. This key MUST be a RSA key that supports encryption. */\n  wrappingKey?: JsonWebKey;\n  /** The export key encryption key identifier. This key MUST be a RSA key that supports encryption. */\n  wrappingKid?: string;\n  /** The encryption algorithm to use to protected the exported key material */\n  enc?: KeyEncryptionAlgorithm;\n}\n\n/** The attributes of a key managed by the key vault service. */\nexport type KeyAttributes = Attributes & {\n  /**\n   * softDelete data retention days. Value should be >=7 and <=90 when softDelete enabled, otherwise 0.\n   * NOTE: This property will not be serialized. It can only be populated by the server.\n   */\n  readonly recoverableDays?: number;\n  /**\n   * Reflects the deletion recovery level currently in effect for keys in the current vault. If it contains 'Purgeable' the key can be permanently deleted by a privileged user; otherwise, only the system can purge the key, at the end of the retention interval.\n   * NOTE: This property will not be serialized. It can only be populated by the server.\n   */\n  readonly recoveryLevel?: DeletionRecoveryLevel;\n  /** Indicates if the private key can be exported. Release policy must be provided when creating the first version of an exportable key. */\n  exportable?: boolean;\n};\n\n/** A DeletedKeyBundle consisting of a WebKey plus its Attributes and deletion info */\nexport type DeletedKeyBundle = KeyBundle & {\n  /** The url of the recovery object, used to identify and recover the deleted key. */\n  recoveryId?: string;\n  /**\n   * The time when the key is scheduled to be purged, in UTC\n   * NOTE: This property will not be serialized. It can only be populated by the server.\n   */\n  readonly scheduledPurgeDate?: Date;\n  /**\n   * The time when the key was deleted, in UTC\n   * NOTE: This property will not be serialized. It can only be populated by the server.\n   */\n  readonly deletedDate?: Date;\n};\n\n/** The deleted key item containing the deleted key metadata and information about deletion. */\nexport type DeletedKeyItem = KeyItem & {\n  /** The url of the recovery object, used to identify and recover the deleted key. */\n  recoveryId?: string;\n  /**\n   * The time when the key is scheduled to be purged, in UTC\n   * NOTE: This property will not be serialized. It can only be populated by the server.\n   */\n  readonly scheduledPurgeDate?: Date;\n  /**\n   * The time when the key was deleted, in UTC\n   * NOTE: This property will not be serialized. It can only be populated by the server.\n   */\n  readonly deletedDate?: Date;\n};\n\n/** Known values of {@link ApiVersion74} that the service accepts. */\nexport enum KnownApiVersion74 {\n  /** Api Version '7.4' */\n  Seven4 = \"7.4\"\n}\n\n/**\n * Defines values for ApiVersion74. \\\n * {@link KnownApiVersion74} can be used interchangeably with ApiVersion74,\n *  this enum contains the known values that the service supports.\n * ### Known values supported by the service\n * **7.4**: Api Version '7.4'\n */\nexport type ApiVersion74 = string;\n\n/** Known values of {@link JsonWebKeyType} that the service accepts. */\nexport enum KnownJsonWebKeyType {\n  /** Elliptic Curve. */\n  EC = \"EC\",\n  /** Elliptic Curve with a private key which is stored in the HSM. */\n  ECHSM = \"EC-HSM\",\n  /** RSA (https://tools.ietf.org/html/rfc3447) */\n  RSA = \"RSA\",\n  /** RSA with a private key which is stored in the HSM. */\n  RSAHSM = \"RSA-HSM\",\n  /** Octet sequence (used to represent symmetric keys) */\n  Oct = \"oct\",\n  /** Octet sequence (used to represent symmetric keys) which is stored the HSM. */\n  OctHSM = \"oct-HSM\"\n}\n\n/**\n * Defines values for JsonWebKeyType. \\\n * {@link KnownJsonWebKeyType} can be used interchangeably with JsonWebKeyType,\n *  this enum contains the known values that the service supports.\n * ### Known values supported by the service\n * **EC**: Elliptic Curve. \\\n * **EC-HSM**: Elliptic Curve with a private key which is stored in the HSM. \\\n * **RSA**: RSA (https:\\/\\/tools.ietf.org\\/html\\/rfc3447) \\\n * **RSA-HSM**: RSA with a private key which is stored in the HSM. \\\n * **oct**: Octet sequence (used to represent symmetric keys) \\\n * **oct-HSM**: Octet sequence (used to represent symmetric keys) which is stored the HSM.\n */\nexport type JsonWebKeyType = string;\n\n/** Known values of {@link JsonWebKeyOperation} that the service accepts. */\nexport enum KnownJsonWebKeyOperation {\n  Encrypt = \"encrypt\",\n  Decrypt = \"decrypt\",\n  Sign = \"sign\",\n  Verify = \"verify\",\n  WrapKey = \"wrapKey\",\n  UnwrapKey = \"unwrapKey\",\n  Import = \"import\",\n  Export = \"export\"\n}\n\n/**\n * Defines values for JsonWebKeyOperation. \\\n * {@link KnownJsonWebKeyOperation} can be used interchangeably with JsonWebKeyOperation,\n *  this enum contains the known values that the service supports.\n * ### Known values supported by the service\n * **encrypt** \\\n * **decrypt** \\\n * **sign** \\\n * **verify** \\\n * **wrapKey** \\\n * **unwrapKey** \\\n * **import** \\\n * **export**\n */\nexport type JsonWebKeyOperation = string;\n\n/** Known values of {@link DeletionRecoveryLevel} that the service accepts. */\nexport enum KnownDeletionRecoveryLevel {\n  /** Denotes a vault state in which deletion is an irreversible operation, without the possibility for recovery. This level corresponds to no protection being available against a Delete operation; the data is irretrievably lost upon accepting a Delete operation at the entity level or higher (vault, resource group, subscription etc.) */\n  Purgeable = \"Purgeable\",\n  /** Denotes a vault state in which deletion is recoverable, and which also permits immediate and permanent deletion (i.e. purge). This level guarantees the recoverability of the deleted entity during the retention interval (90 days), unless a Purge operation is requested, or the subscription is cancelled. System wil permanently delete it after 90 days, if not recovered */\n  RecoverablePurgeable = \"Recoverable+Purgeable\",\n  /** Denotes a vault state in which deletion is recoverable without the possibility for immediate and permanent deletion (i.e. purge). This level guarantees the recoverability of the deleted entity during the retention interval(90 days) and while the subscription is still available. System wil permanently delete it after 90 days, if not recovered */\n  Recoverable = \"Recoverable\",\n  /** Denotes a vault and subscription state in which deletion is recoverable within retention interval (90 days), immediate and permanent deletion (i.e. purge) is not permitted, and in which the subscription itself  cannot be permanently canceled. System wil permanently delete it after 90 days, if not recovered */\n  RecoverableProtectedSubscription = \"Recoverable+ProtectedSubscription\",\n  /** Denotes a vault state in which deletion is recoverable, and which also permits immediate and permanent deletion (i.e. purge when 7<= SoftDeleteRetentionInDays < 90). This level guarantees the recoverability of the deleted entity during the retention interval, unless a Purge operation is requested, or the subscription is cancelled. */\n  CustomizedRecoverablePurgeable = \"CustomizedRecoverable+Purgeable\",\n  /** Denotes a vault state in which deletion is recoverable without the possibility for immediate and permanent deletion (i.e. purge when 7<= SoftDeleteRetentionInDays < 90).This level guarantees the recoverability of the deleted entity during the retention interval and while the subscription is still available. */\n  CustomizedRecoverable = \"CustomizedRecoverable\",\n  /** Denotes a vault and subscription state in which deletion is recoverable, immediate and permanent deletion (i.e. purge) is not permitted, and in which the subscription itself cannot be permanently canceled when 7<= SoftDeleteRetentionInDays < 90. This level guarantees the recoverability of the deleted entity during the retention interval, and also reflects the fact that the subscription itself cannot be cancelled. */\n  CustomizedRecoverableProtectedSubscription = \"CustomizedRecoverable+ProtectedSubscription\"\n}\n\n/**\n * Defines values for DeletionRecoveryLevel. \\\n * {@link KnownDeletionRecoveryLevel} can be used interchangeably with DeletionRecoveryLevel,\n *  this enum contains the known values that the service supports.\n * ### Known values supported by the service\n * **Purgeable**: Denotes a vault state in which deletion is an irreversible operation, without the possibility for recovery. This level corresponds to no protection being available against a Delete operation; the data is irretrievably lost upon accepting a Delete operation at the entity level or higher (vault, resource group, subscription etc.) \\\n * **Recoverable+Purgeable**: Denotes a vault state in which deletion is recoverable, and which also permits immediate and permanent deletion (i.e. purge). This level guarantees the recoverability of the deleted entity during the retention interval (90 days), unless a Purge operation is requested, or the subscription is cancelled. System wil permanently delete it after 90 days, if not recovered \\\n * **Recoverable**: Denotes a vault state in which deletion is recoverable without the possibility for immediate and permanent deletion (i.e. purge). This level guarantees the recoverability of the deleted entity during the retention interval(90 days) and while the subscription is still available. System wil permanently delete it after 90 days, if not recovered \\\n * **Recoverable+ProtectedSubscription**: Denotes a vault and subscription state in which deletion is recoverable within retention interval (90 days), immediate and permanent deletion (i.e. purge) is not permitted, and in which the subscription itself  cannot be permanently canceled. System wil permanently delete it after 90 days, if not recovered \\\n * **CustomizedRecoverable+Purgeable**: Denotes a vault state in which deletion is recoverable, and which also permits immediate and permanent deletion (i.e. purge when 7<= SoftDeleteRetentionInDays < 90). This level guarantees the recoverability of the deleted entity during the retention interval, unless a Purge operation is requested, or the subscription is cancelled. \\\n * **CustomizedRecoverable**: Denotes a vault state in which deletion is recoverable without the possibility for immediate and permanent deletion (i.e. purge when 7<= SoftDeleteRetentionInDays < 90).This level guarantees the recoverability of the deleted entity during the retention interval and while the subscription is still available. \\\n * **CustomizedRecoverable+ProtectedSubscription**: Denotes a vault and subscription state in which deletion is recoverable, immediate and permanent deletion (i.e. purge) is not permitted, and in which the subscription itself cannot be permanently canceled when 7<= SoftDeleteRetentionInDays < 90. This level guarantees the recoverability of the deleted entity during the retention interval, and also reflects the fact that the subscription itself cannot be cancelled.\n */\nexport type DeletionRecoveryLevel = string;\n\n/** Known values of {@link JsonWebKeyCurveName} that the service accepts. */\nexport enum KnownJsonWebKeyCurveName {\n  /** The NIST P-256 elliptic curve, AKA SECG curve SECP256R1. */\n  P256 = \"P-256\",\n  /** The NIST P-384 elliptic curve, AKA SECG curve SECP384R1. */\n  P384 = \"P-384\",\n  /** The NIST P-521 elliptic curve, AKA SECG curve SECP521R1. */\n  P521 = \"P-521\",\n  /** The SECG SECP256K1 elliptic curve. */\n  P256K = \"P-256K\"\n}\n\n/**\n * Defines values for JsonWebKeyCurveName. \\\n * {@link KnownJsonWebKeyCurveName} can be used interchangeably with JsonWebKeyCurveName,\n *  this enum contains the known values that the service supports.\n * ### Known values supported by the service\n * **P-256**: The NIST P-256 elliptic curve, AKA SECG curve SECP256R1. \\\n * **P-384**: The NIST P-384 elliptic curve, AKA SECG curve SECP384R1. \\\n * **P-521**: The NIST P-521 elliptic curve, AKA SECG curve SECP521R1. \\\n * **P-256K**: The SECG SECP256K1 elliptic curve.\n */\nexport type JsonWebKeyCurveName = string;\n\n/** Known values of {@link JsonWebKeyEncryptionAlgorithm} that the service accepts. */\nexport enum KnownJsonWebKeyEncryptionAlgorithm {\n  RSAOaep = \"RSA-OAEP\",\n  RSAOaep256 = \"RSA-OAEP-256\",\n  RSA15 = \"RSA1_5\",\n  A128GCM = \"A128GCM\",\n  A192GCM = \"A192GCM\",\n  A256GCM = \"A256GCM\",\n  A128KW = \"A128KW\",\n  A192KW = \"A192KW\",\n  A256KW = \"A256KW\",\n  A128CBC = \"A128CBC\",\n  A192CBC = \"A192CBC\",\n  A256CBC = \"A256CBC\",\n  A128Cbcpad = \"A128CBCPAD\",\n  A192Cbcpad = \"A192CBCPAD\",\n  A256Cbcpad = \"A256CBCPAD\"\n}\n\n/**\n * Defines values for JsonWebKeyEncryptionAlgorithm. \\\n * {@link KnownJsonWebKeyEncryptionAlgorithm} can be used interchangeably with JsonWebKeyEncryptionAlgorithm,\n *  this enum contains the known values that the service supports.\n * ### Known values supported by the service\n * **RSA-OAEP** \\\n * **RSA-OAEP-256** \\\n * **RSA1_5** \\\n * **A128GCM** \\\n * **A192GCM** \\\n * **A256GCM** \\\n * **A128KW** \\\n * **A192KW** \\\n * **A256KW** \\\n * **A128CBC** \\\n * **A192CBC** \\\n * **A256CBC** \\\n * **A128CBCPAD** \\\n * **A192CBCPAD** \\\n * **A256CBCPAD**\n */\nexport type JsonWebKeyEncryptionAlgorithm = string;\n\n/** Known values of {@link JsonWebKeySignatureAlgorithm} that the service accepts. */\nexport enum KnownJsonWebKeySignatureAlgorithm {\n  /** RSASSA-PSS using SHA-256 and MGF1 with SHA-256, as described in https://tools.ietf.org/html/rfc7518 */\n  PS256 = \"PS256\",\n  /** RSASSA-PSS using SHA-384 and MGF1 with SHA-384, as described in https://tools.ietf.org/html/rfc7518 */\n  PS384 = \"PS384\",\n  /** RSASSA-PSS using SHA-512 and MGF1 with SHA-512, as described in https://tools.ietf.org/html/rfc7518 */\n  PS512 = \"PS512\",\n  /** RSASSA-PKCS1-v1_5 using SHA-256, as described in https://tools.ietf.org/html/rfc7518 */\n  RS256 = \"RS256\",\n  /** RSASSA-PKCS1-v1_5 using SHA-384, as described in https://tools.ietf.org/html/rfc7518 */\n  RS384 = \"RS384\",\n  /** RSASSA-PKCS1-v1_5 using SHA-512, as described in https://tools.ietf.org/html/rfc7518 */\n  RS512 = \"RS512\",\n  /** Reserved */\n  Rsnull = \"RSNULL\",\n  /** ECDSA using P-256 and SHA-256, as described in https://tools.ietf.org/html/rfc7518. */\n  ES256 = \"ES256\",\n  /** ECDSA using P-384 and SHA-384, as described in https://tools.ietf.org/html/rfc7518 */\n  ES384 = \"ES384\",\n  /** ECDSA using P-521 and SHA-512, as described in https://tools.ietf.org/html/rfc7518 */\n  ES512 = \"ES512\",\n  /** ECDSA using P-256K and SHA-256, as described in https://tools.ietf.org/html/rfc7518 */\n  ES256K = \"ES256K\"\n}\n\n/**\n * Defines values for JsonWebKeySignatureAlgorithm. \\\n * {@link KnownJsonWebKeySignatureAlgorithm} can be used interchangeably with JsonWebKeySignatureAlgorithm,\n *  this enum contains the known values that the service supports.\n * ### Known values supported by the service\n * **PS256**: RSASSA-PSS using SHA-256 and MGF1 with SHA-256, as described in https:\\/\\/tools.ietf.org\\/html\\/rfc7518 \\\n * **PS384**: RSASSA-PSS using SHA-384 and MGF1 with SHA-384, as described in https:\\/\\/tools.ietf.org\\/html\\/rfc7518 \\\n * **PS512**: RSASSA-PSS using SHA-512 and MGF1 with SHA-512, as described in https:\\/\\/tools.ietf.org\\/html\\/rfc7518 \\\n * **RS256**: RSASSA-PKCS1-v1_5 using SHA-256, as described in https:\\/\\/tools.ietf.org\\/html\\/rfc7518 \\\n * **RS384**: RSASSA-PKCS1-v1_5 using SHA-384, as described in https:\\/\\/tools.ietf.org\\/html\\/rfc7518 \\\n * **RS512**: RSASSA-PKCS1-v1_5 using SHA-512, as described in https:\\/\\/tools.ietf.org\\/html\\/rfc7518 \\\n * **RSNULL**: Reserved \\\n * **ES256**: ECDSA using P-256 and SHA-256, as described in https:\\/\\/tools.ietf.org\\/html\\/rfc7518. \\\n * **ES384**: ECDSA using P-384 and SHA-384, as described in https:\\/\\/tools.ietf.org\\/html\\/rfc7518 \\\n * **ES512**: ECDSA using P-521 and SHA-512, as described in https:\\/\\/tools.ietf.org\\/html\\/rfc7518 \\\n * **ES256K**: ECDSA using P-256K and SHA-256, as described in https:\\/\\/tools.ietf.org\\/html\\/rfc7518\n */\nexport type JsonWebKeySignatureAlgorithm = string;\n\n/** Known values of {@link KeyEncryptionAlgorithm} that the service accepts. */\nexport enum KnownKeyEncryptionAlgorithm {\n  CKMRSAAESKEYWrap = \"CKM_RSA_AES_KEY_WRAP\",\n  RSAAESKEYWrap256 = \"RSA_AES_KEY_WRAP_256\",\n  RSAAESKEYWrap384 = \"RSA_AES_KEY_WRAP_384\"\n}\n\n/**\n * Defines values for KeyEncryptionAlgorithm. \\\n * {@link KnownKeyEncryptionAlgorithm} can be used interchangeably with KeyEncryptionAlgorithm,\n *  this enum contains the known values that the service supports.\n * ### Known values supported by the service\n * **CKM_RSA_AES_KEY_WRAP** \\\n * **RSA_AES_KEY_WRAP_256** \\\n * **RSA_AES_KEY_WRAP_384**\n */\nexport type KeyEncryptionAlgorithm = string;\n/** Defines values for ActionType. */\nexport type ActionType = \"Rotate\" | \"Notify\";\n\n/** Optional parameters. */\nexport interface CreateKeyOptionalParams extends coreClient.OperationOptions {\n  /** The key size in bits. For example: 2048, 3072, or 4096 for RSA. */\n  keySize?: number;\n  /** The public exponent for a RSA key. */\n  publicExponent?: number;\n  /** Array of JsonWebKeyOperation */\n  keyOps?: JsonWebKeyOperation[];\n  /** The attributes of a key managed by the key vault service. */\n  keyAttributes?: KeyAttributes;\n  /** Application specific metadata in the form of key-value pairs. */\n  tags?: { [propertyName: string]: string };\n  /** Elliptic curve name. For valid values, see JsonWebKeyCurveName. */\n  curve?: JsonWebKeyCurveName;\n  /** The policy rules under which the key can be exported. */\n  releasePolicy?: KeyReleasePolicy;\n}\n\n/** Contains response data for the createKey operation. */\nexport type CreateKeyResponse = KeyBundle;\n\n/** Optional parameters. */\nexport interface RotateKeyOptionalParams extends coreClient.OperationOptions {}\n\n/** Contains response data for the rotateKey operation. */\nexport type RotateKeyResponse = KeyBundle;\n\n/** Optional parameters. */\nexport interface ImportKeyOptionalParams extends coreClient.OperationOptions {\n  /** Whether to import as a hardware key (HSM) or software key. */\n  hsm?: boolean;\n  /** The key management attributes. */\n  keyAttributes?: KeyAttributes;\n  /** Application specific metadata in the form of key-value pairs. */\n  tags?: { [propertyName: string]: string };\n  /** The policy rules under which the key can be exported. */\n  releasePolicy?: KeyReleasePolicy;\n}\n\n/** Contains response data for the importKey operation. */\nexport type ImportKeyResponse = KeyBundle;\n\n/** Optional parameters. */\nexport interface DeleteKeyOptionalParams extends coreClient.OperationOptions {}\n\n/** Contains response data for the deleteKey operation. */\nexport type DeleteKeyResponse = DeletedKeyBundle;\n\n/** Optional parameters. */\nexport interface UpdateKeyOptionalParams extends coreClient.OperationOptions {\n  /** Json web key operations. For more information on possible key operations, see JsonWebKeyOperation. */\n  keyOps?: JsonWebKeyOperation[];\n  /** The attributes of a key managed by the key vault service. */\n  keyAttributes?: KeyAttributes;\n  /** Application specific metadata in the form of key-value pairs. */\n  tags?: { [propertyName: string]: string };\n  /** The policy rules under which the key can be exported. */\n  releasePolicy?: KeyReleasePolicy;\n}\n\n/** Contains response data for the updateKey operation. */\nexport type UpdateKeyResponse = KeyBundle;\n\n/** Optional parameters. */\nexport interface GetKeyOptionalParams extends coreClient.OperationOptions {}\n\n/** Contains response data for the getKey operation. */\nexport type GetKeyResponse = KeyBundle;\n\n/** Optional parameters. */\nexport interface GetKeyVersionsOptionalParams\n  extends coreClient.OperationOptions {\n  /** Maximum number of results to return in a page. If not specified the service will return up to 25 results. */\n  maxresults?: number;\n}\n\n/** Contains response data for the getKeyVersions operation. */\nexport type GetKeyVersionsResponse = KeyListResult;\n\n/** Optional parameters. */\nexport interface GetKeysOptionalParams extends coreClient.OperationOptions {\n  /** Maximum number of results to return in a page. If not specified the service will return up to 25 results. */\n  maxresults?: number;\n}\n\n/** Contains response data for the getKeys operation. */\nexport type GetKeysResponse = KeyListResult;\n\n/** Optional parameters. */\nexport interface BackupKeyOptionalParams extends coreClient.OperationOptions {}\n\n/** Contains response data for the backupKey operation. */\nexport type BackupKeyResponse = BackupKeyResult;\n\n/** Optional parameters. */\nexport interface RestoreKeyOptionalParams extends coreClient.OperationOptions {}\n\n/** Contains response data for the restoreKey operation. */\nexport type RestoreKeyResponse = KeyBundle;\n\n/** Optional parameters. */\nexport interface EncryptOptionalParams extends coreClient.OperationOptions {\n  /** Cryptographically random, non-repeating initialization vector for symmetric algorithms. */\n  iv?: Uint8Array;\n  /** Additional data to authenticate but not encrypt/decrypt when using authenticated crypto algorithms. */\n  additionalAuthenticatedData?: Uint8Array;\n  /** The tag to authenticate when performing decryption with an authenticated algorithm. */\n  authenticationTag?: Uint8Array;\n}\n\n/** Contains response data for the encrypt operation. */\nexport type EncryptResponse = KeyOperationResult;\n\n/** Optional parameters. */\nexport interface DecryptOptionalParams extends coreClient.OperationOptions {\n  /** Cryptographically random, non-repeating initialization vector for symmetric algorithms. */\n  iv?: Uint8Array;\n  /** Additional data to authenticate but not encrypt/decrypt when using authenticated crypto algorithms. */\n  additionalAuthenticatedData?: Uint8Array;\n  /** The tag to authenticate when performing decryption with an authenticated algorithm. */\n  authenticationTag?: Uint8Array;\n}\n\n/** Contains response data for the decrypt operation. */\nexport type DecryptResponse = KeyOperationResult;\n\n/** Optional parameters. */\nexport interface SignOptionalParams extends coreClient.OperationOptions {}\n\n/** Contains response data for the sign operation. */\nexport type SignResponse = KeyOperationResult;\n\n/** Optional parameters. */\nexport interface VerifyOptionalParams extends coreClient.OperationOptions {}\n\n/** Contains response data for the verify operation. */\nexport type VerifyResponse = KeyVerifyResult;\n\n/** Optional parameters. */\nexport interface WrapKeyOptionalParams extends coreClient.OperationOptions {\n  /** Cryptographically random, non-repeating initialization vector for symmetric algorithms. */\n  iv?: Uint8Array;\n  /** Additional data to authenticate but not encrypt/decrypt when using authenticated crypto algorithms. */\n  additionalAuthenticatedData?: Uint8Array;\n  /** The tag to authenticate when performing decryption with an authenticated algorithm. */\n  authenticationTag?: Uint8Array;\n}\n\n/** Contains response data for the wrapKey operation. */\nexport type WrapKeyResponse = KeyOperationResult;\n\n/** Optional parameters. */\nexport interface UnwrapKeyOptionalParams extends coreClient.OperationOptions {\n  /** Cryptographically random, non-repeating initialization vector for symmetric algorithms. */\n  iv?: Uint8Array;\n  /** Additional data to authenticate but not encrypt/decrypt when using authenticated crypto algorithms. */\n  additionalAuthenticatedData?: Uint8Array;\n  /** The tag to authenticate when performing decryption with an authenticated algorithm. */\n  authenticationTag?: Uint8Array;\n}\n\n/** Contains response data for the unwrapKey operation. */\nexport type UnwrapKeyResponse = KeyOperationResult;\n\n/** Optional parameters. */\nexport interface ReleaseOptionalParams extends coreClient.OperationOptions {\n  /** A client provided nonce for freshness. */\n  nonce?: string;\n  /** The encryption algorithm to use to protected the exported key material */\n  enc?: KeyEncryptionAlgorithm;\n}\n\n/** Contains response data for the release operation. */\nexport type ReleaseResponse = KeyReleaseResult;\n\n/** Optional parameters. */\nexport interface GetDeletedKeysOptionalParams\n  extends coreClient.OperationOptions {\n  /** Maximum number of results to return in a page. If not specified the service will return up to 25 results. */\n  maxresults?: number;\n}\n\n/** Contains response data for the getDeletedKeys operation. */\nexport type GetDeletedKeysResponse = DeletedKeyListResult;\n\n/** Optional parameters. */\nexport interface GetDeletedKeyOptionalParams\n  extends coreClient.OperationOptions {}\n\n/** Contains response data for the getDeletedKey operation. */\nexport type GetDeletedKeyResponse = DeletedKeyBundle;\n\n/** Optional parameters. */\nexport interface PurgeDeletedKeyOptionalParams\n  extends coreClient.OperationOptions {}\n\n/** Optional parameters. */\nexport interface RecoverDeletedKeyOptionalParams\n  extends coreClient.OperationOptions {}\n\n/** Contains response data for the recoverDeletedKey operation. */\nexport type RecoverDeletedKeyResponse = KeyBundle;\n\n/** Optional parameters. */\nexport interface GetKeyRotationPolicyOptionalParams\n  extends coreClient.OperationOptions {}\n\n/** Contains response data for the getKeyRotationPolicy operation. */\nexport type GetKeyRotationPolicyResponse = KeyRotationPolicy;\n\n/** Optional parameters. */\nexport interface UpdateKeyRotationPolicyOptionalParams\n  extends coreClient.OperationOptions {}\n\n/** Contains response data for the updateKeyRotationPolicy operation. */\nexport type UpdateKeyRotationPolicyResponse = KeyRotationPolicy;\n\n/** Optional parameters. */\nexport interface GetRandomBytesOptionalParams\n  extends coreClient.OperationOptions {}\n\n/** Contains response data for the getRandomBytes operation. */\nexport type GetRandomBytesResponse = RandomBytes;\n\n/** Optional parameters. */\nexport interface GetKeyVersionsNextOptionalParams\n  extends coreClient.OperationOptions {\n  /** Maximum number of results to return in a page. If not specified the service will return up to 25 results. */\n  maxresults?: number;\n}\n\n/** Contains response data for the getKeyVersionsNext operation. */\nexport type GetKeyVersionsNextResponse = KeyListResult;\n\n/** Optional parameters. */\nexport interface GetKeysNextOptionalParams extends coreClient.OperationOptions {\n  /** Maximum number of results to return in a page. If not specified the service will return up to 25 results. */\n  maxresults?: number;\n}\n\n/** Contains response data for the getKeysNext operation. */\nexport type GetKeysNextResponse = KeyListResult;\n\n/** Optional parameters. */\nexport interface GetDeletedKeysNextOptionalParams\n  extends coreClient.OperationOptions {\n  /** Maximum number of results to return in a page. If not specified the service will return up to 25 results. */\n  maxresults?: number;\n}\n\n/** Contains response data for the getDeletedKeysNext operation. */\nexport type GetDeletedKeysNextResponse = DeletedKeyListResult;\n\n/** Optional parameters. */\nexport interface KeyVaultClientOptionalParams\n  extends coreHttpCompat.ExtendedServiceClientOptions {\n  /** Overrides client endpoint. */\n  endpoint?: string;\n}\n","/*\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT License.\n *\n * Code generated by Microsoft (R) AutoRest Code Generator.\n * Changes may cause incorrect behavior and will be lost if the code is regenerated.\n */\n\nimport * as coreClient from \"@azure/core-client\";\n\nexport const KeyCreateParameters: coreClient.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"KeyCreateParameters\",\n    modelProperties: {\n      kty: {\n        serializedName: \"kty\",\n        required: true,\n        type: {\n          name: \"String\"\n        }\n      },\n      keySize: {\n        serializedName: \"key_size\",\n        type: {\n          name: \"Number\"\n        }\n      },\n      publicExponent: {\n        serializedName: \"public_exponent\",\n        type: {\n          name: \"Number\"\n        }\n      },\n      keyOps: {\n        serializedName: \"key_ops\",\n        type: {\n          name: \"Sequence\",\n          element: {\n            type: {\n              name: \"String\"\n            }\n          }\n        }\n      },\n      keyAttributes: {\n        serializedName: \"attributes\",\n        type: {\n          name: \"Composite\",\n          className: \"KeyAttributes\"\n        }\n      },\n      tags: {\n        serializedName: \"tags\",\n        type: {\n          name: \"Dictionary\",\n          value: { type: { name: \"String\" } }\n        }\n      },\n      curve: {\n        serializedName: \"crv\",\n        type: {\n          name: \"String\"\n        }\n      },\n      releasePolicy: {\n        serializedName: \"release_policy\",\n        type: {\n          name: \"Composite\",\n          className: \"KeyReleasePolicy\"\n        }\n      }\n    }\n  }\n};\n\nexport const Attributes: coreClient.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"Attributes\",\n    modelProperties: {\n      enabled: {\n        serializedName: \"enabled\",\n        type: {\n          name: \"Boolean\"\n        }\n      },\n      notBefore: {\n        serializedName: \"nbf\",\n        type: {\n          name: \"UnixTime\"\n        }\n      },\n      expires: {\n        serializedName: \"exp\",\n        type: {\n          name: \"UnixTime\"\n        }\n      },\n      created: {\n        serializedName: \"created\",\n        readOnly: true,\n        type: {\n          name: \"UnixTime\"\n        }\n      },\n      updated: {\n        serializedName: \"updated\",\n        readOnly: true,\n        type: {\n          name: \"UnixTime\"\n        }\n      }\n    }\n  }\n};\n\nexport const KeyReleasePolicy: coreClient.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"KeyReleasePolicy\",\n    modelProperties: {\n      contentType: {\n        defaultValue: \"application/json; charset=utf-8\",\n        serializedName: \"contentType\",\n        type: {\n          name: \"String\"\n        }\n      },\n      immutable: {\n        serializedName: \"immutable\",\n        type: {\n          name: \"Boolean\"\n        }\n      },\n      encodedPolicy: {\n        serializedName: \"data\",\n        type: {\n          name: \"Base64Url\"\n        }\n      }\n    }\n  }\n};\n\nexport const KeyBundle: coreClient.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"KeyBundle\",\n    modelProperties: {\n      key: {\n        serializedName: \"key\",\n        type: {\n          name: \"Composite\",\n          className: \"JsonWebKey\"\n        }\n      },\n      attributes: {\n        serializedName: \"attributes\",\n        type: {\n          name: \"Composite\",\n          className: \"KeyAttributes\"\n        }\n      },\n      tags: {\n        serializedName: \"tags\",\n        type: {\n          name: \"Dictionary\",\n          value: { type: { name: \"String\" } }\n        }\n      },\n      managed: {\n        serializedName: \"managed\",\n        readOnly: true,\n        type: {\n          name: \"Boolean\"\n        }\n      },\n      releasePolicy: {\n        serializedName: \"release_policy\",\n        type: {\n          name: \"Composite\",\n          className: \"KeyReleasePolicy\"\n        }\n      }\n    }\n  }\n};\n\nexport const JsonWebKey: coreClient.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"JsonWebKey\",\n    modelProperties: {\n      kid: {\n        serializedName: \"kid\",\n        type: {\n          name: \"String\"\n        }\n      },\n      kty: {\n        serializedName: \"kty\",\n        type: {\n          name: \"String\"\n        }\n      },\n      keyOps: {\n        serializedName: \"key_ops\",\n        type: {\n          name: \"Sequence\",\n          element: {\n            type: {\n              name: \"String\"\n            }\n          }\n        }\n      },\n      n: {\n        serializedName: \"n\",\n        type: {\n          name: \"Base64Url\"\n        }\n      },\n      e: {\n        serializedName: \"e\",\n        type: {\n          name: \"Base64Url\"\n        }\n      },\n      d: {\n        serializedName: \"d\",\n        type: {\n          name: \"Base64Url\"\n        }\n      },\n      dp: {\n        serializedName: \"dp\",\n        type: {\n          name: \"Base64Url\"\n        }\n      },\n      dq: {\n        serializedName: \"dq\",\n        type: {\n          name: \"Base64Url\"\n        }\n      },\n      qi: {\n        serializedName: \"qi\",\n        type: {\n          name: \"Base64Url\"\n        }\n      },\n      p: {\n        serializedName: \"p\",\n        type: {\n          name: \"Base64Url\"\n        }\n      },\n      q: {\n        serializedName: \"q\",\n        type: {\n          name: \"Base64Url\"\n        }\n      },\n      k: {\n        serializedName: \"k\",\n        type: {\n          name: \"Base64Url\"\n        }\n      },\n      t: {\n        serializedName: \"key_hsm\",\n        type: {\n          name: \"Base64Url\"\n        }\n      },\n      crv: {\n        serializedName: \"crv\",\n        type: {\n          name: \"String\"\n        }\n      },\n      x: {\n        serializedName: \"x\",\n        type: {\n          name: \"Base64Url\"\n        }\n      },\n      y: {\n        serializedName: \"y\",\n        type: {\n          name: \"Base64Url\"\n        }\n      }\n    }\n  }\n};\n\nexport const KeyVaultError: coreClient.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"KeyVaultError\",\n    modelProperties: {\n      error: {\n        serializedName: \"error\",\n        type: {\n          name: \"Composite\",\n          className: \"ErrorModel\"\n        }\n      }\n    }\n  }\n};\n\nexport const ErrorModel: coreClient.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"ErrorModel\",\n    modelProperties: {\n      code: {\n        serializedName: \"code\",\n        readOnly: true,\n        type: {\n          name: \"String\"\n        }\n      },\n      message: {\n        serializedName: \"message\",\n        readOnly: true,\n        type: {\n          name: \"String\"\n        }\n      },\n      innerError: {\n        serializedName: \"innererror\",\n        type: {\n          name: \"Composite\",\n          className: \"ErrorModel\"\n        }\n      }\n    }\n  }\n};\n\nexport const KeyImportParameters: coreClient.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"KeyImportParameters\",\n    modelProperties: {\n      hsm: {\n        serializedName: \"Hsm\",\n        type: {\n          name: \"Boolean\"\n        }\n      },\n      key: {\n        serializedName: \"key\",\n        type: {\n          name: \"Composite\",\n          className: \"JsonWebKey\"\n        }\n      },\n      keyAttributes: {\n        serializedName: \"attributes\",\n        type: {\n          name: \"Composite\",\n          className: \"KeyAttributes\"\n        }\n      },\n      tags: {\n        serializedName: \"tags\",\n        type: {\n          name: \"Dictionary\",\n          value: { type: { name: \"String\" } }\n        }\n      },\n      releasePolicy: {\n        serializedName: \"release_policy\",\n        type: {\n          name: \"Composite\",\n          className: \"KeyReleasePolicy\"\n        }\n      }\n    }\n  }\n};\n\nexport const KeyUpdateParameters: coreClient.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"KeyUpdateParameters\",\n    modelProperties: {\n      keyOps: {\n        serializedName: \"key_ops\",\n        type: {\n          name: \"Sequence\",\n          element: {\n            type: {\n              name: \"String\"\n            }\n          }\n        }\n      },\n      keyAttributes: {\n        serializedName: \"attributes\",\n        type: {\n          name: \"Composite\",\n          className: \"KeyAttributes\"\n        }\n      },\n      tags: {\n        serializedName: \"tags\",\n        type: {\n          name: \"Dictionary\",\n          value: { type: { name: \"String\" } }\n        }\n      },\n      releasePolicy: {\n        serializedName: \"release_policy\",\n        type: {\n          name: \"Composite\",\n          className: \"KeyReleasePolicy\"\n        }\n      }\n    }\n  }\n};\n\nexport const KeyListResult: coreClient.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"KeyListResult\",\n    modelProperties: {\n      value: {\n        serializedName: \"value\",\n        readOnly: true,\n        type: {\n          name: \"Sequence\",\n          element: {\n            type: {\n              name: \"Composite\",\n              className: \"KeyItem\"\n            }\n          }\n        }\n      },\n      nextLink: {\n        serializedName: \"nextLink\",\n        readOnly: true,\n        type: {\n          name: \"String\"\n        }\n      }\n    }\n  }\n};\n\nexport const KeyItem: coreClient.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"KeyItem\",\n    modelProperties: {\n      kid: {\n        serializedName: \"kid\",\n        type: {\n          name: \"String\"\n        }\n      },\n      attributes: {\n        serializedName: \"attributes\",\n        type: {\n          name: \"Composite\",\n          className: \"KeyAttributes\"\n        }\n      },\n      tags: {\n        serializedName: \"tags\",\n        type: {\n          name: \"Dictionary\",\n          value: { type: { name: \"String\" } }\n        }\n      },\n      managed: {\n        serializedName: \"managed\",\n        readOnly: true,\n        type: {\n          name: \"Boolean\"\n        }\n      }\n    }\n  }\n};\n\nexport const BackupKeyResult: coreClient.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"BackupKeyResult\",\n    modelProperties: {\n      value: {\n        serializedName: \"value\",\n        readOnly: true,\n        type: {\n          name: \"Base64Url\"\n        }\n      }\n    }\n  }\n};\n\nexport const KeyRestoreParameters: coreClient.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"KeyRestoreParameters\",\n    modelProperties: {\n      keyBundleBackup: {\n        serializedName: \"value\",\n        required: true,\n        type: {\n          name: \"Base64Url\"\n        }\n      }\n    }\n  }\n};\n\nexport const KeyOperationsParameters: coreClient.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"KeyOperationsParameters\",\n    modelProperties: {\n      algorithm: {\n        serializedName: \"alg\",\n        required: true,\n        type: {\n          name: \"String\"\n        }\n      },\n      value: {\n        serializedName: \"value\",\n        required: true,\n        type: {\n          name: \"Base64Url\"\n        }\n      },\n      iv: {\n        serializedName: \"iv\",\n        type: {\n          name: \"Base64Url\"\n        }\n      },\n      additionalAuthenticatedData: {\n        serializedName: \"aad\",\n        type: {\n          name: \"Base64Url\"\n        }\n      },\n      authenticationTag: {\n        serializedName: \"tag\",\n        type: {\n          name: \"Base64Url\"\n        }\n      }\n    }\n  }\n};\n\nexport const KeyOperationResult: coreClient.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"KeyOperationResult\",\n    modelProperties: {\n      kid: {\n        serializedName: \"kid\",\n        readOnly: true,\n        type: {\n          name: \"String\"\n        }\n      },\n      result: {\n        serializedName: \"value\",\n        readOnly: true,\n        type: {\n          name: \"Base64Url\"\n        }\n      },\n      iv: {\n        serializedName: \"iv\",\n        readOnly: true,\n        type: {\n          name: \"Base64Url\"\n        }\n      },\n      authenticationTag: {\n        serializedName: \"tag\",\n        readOnly: true,\n        type: {\n          name: \"Base64Url\"\n        }\n      },\n      additionalAuthenticatedData: {\n        serializedName: \"aad\",\n        readOnly: true,\n        type: {\n          name: \"Base64Url\"\n        }\n      }\n    }\n  }\n};\n\nexport const KeySignParameters: coreClient.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"KeySignParameters\",\n    modelProperties: {\n      algorithm: {\n        serializedName: \"alg\",\n        required: true,\n        type: {\n          name: \"String\"\n        }\n      },\n      value: {\n        serializedName: \"value\",\n        required: true,\n        type: {\n          name: \"Base64Url\"\n        }\n      }\n    }\n  }\n};\n\nexport const KeyVerifyParameters: coreClient.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"KeyVerifyParameters\",\n    modelProperties: {\n      algorithm: {\n        serializedName: \"alg\",\n        required: true,\n        type: {\n          name: \"String\"\n        }\n      },\n      digest: {\n        serializedName: \"digest\",\n        required: true,\n        type: {\n          name: \"Base64Url\"\n        }\n      },\n      signature: {\n        serializedName: \"value\",\n        required: true,\n        type: {\n          name: \"Base64Url\"\n        }\n      }\n    }\n  }\n};\n\nexport const KeyVerifyResult: coreClient.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"KeyVerifyResult\",\n    modelProperties: {\n      value: {\n        serializedName: \"value\",\n        readOnly: true,\n        type: {\n          name: \"Boolean\"\n        }\n      }\n    }\n  }\n};\n\nexport const KeyReleaseParameters: coreClient.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"KeyReleaseParameters\",\n    modelProperties: {\n      targetAttestationToken: {\n        constraints: {\n          MinLength: 1\n        },\n        serializedName: \"target\",\n        required: true,\n        type: {\n          name: \"String\"\n        }\n      },\n      nonce: {\n        serializedName: \"nonce\",\n        type: {\n          name: \"String\"\n        }\n      },\n      enc: {\n        serializedName: \"enc\",\n        type: {\n          name: \"String\"\n        }\n      }\n    }\n  }\n};\n\nexport const KeyReleaseResult: coreClient.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"KeyReleaseResult\",\n    modelProperties: {\n      value: {\n        serializedName: \"value\",\n        readOnly: true,\n        type: {\n          name: \"String\"\n        }\n      }\n    }\n  }\n};\n\nexport const DeletedKeyListResult: coreClient.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"DeletedKeyListResult\",\n    modelProperties: {\n      value: {\n        serializedName: \"value\",\n        readOnly: true,\n        type: {\n          name: \"Sequence\",\n          element: {\n            type: {\n              name: \"Composite\",\n              className: \"DeletedKeyItem\"\n            }\n          }\n        }\n      },\n      nextLink: {\n        serializedName: \"nextLink\",\n        readOnly: true,\n        type: {\n          name: \"String\"\n        }\n      }\n    }\n  }\n};\n\nexport const KeyRotationPolicy: coreClient.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"KeyRotationPolicy\",\n    modelProperties: {\n      id: {\n        serializedName: \"id\",\n        readOnly: true,\n        type: {\n          name: \"String\"\n        }\n      },\n      lifetimeActions: {\n        serializedName: \"lifetimeActions\",\n        type: {\n          name: \"Sequence\",\n          element: {\n            type: {\n              name: \"Composite\",\n              className: \"LifetimeActions\"\n            }\n          }\n        }\n      },\n      attributes: {\n        serializedName: \"attributes\",\n        type: {\n          name: \"Composite\",\n          className: \"KeyRotationPolicyAttributes\"\n        }\n      }\n    }\n  }\n};\n\nexport const LifetimeActions: coreClient.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"LifetimeActions\",\n    modelProperties: {\n      trigger: {\n        serializedName: \"trigger\",\n        type: {\n          name: \"Composite\",\n          className: \"LifetimeActionsTrigger\"\n        }\n      },\n      action: {\n        serializedName: \"action\",\n        type: {\n          name: \"Composite\",\n          className: \"LifetimeActionsType\"\n        }\n      }\n    }\n  }\n};\n\nexport const LifetimeActionsTrigger: coreClient.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"LifetimeActionsTrigger\",\n    modelProperties: {\n      timeAfterCreate: {\n        serializedName: \"timeAfterCreate\",\n        type: {\n          name: \"String\"\n        }\n      },\n      timeBeforeExpiry: {\n        serializedName: \"timeBeforeExpiry\",\n        type: {\n          name: \"String\"\n        }\n      }\n    }\n  }\n};\n\nexport const LifetimeActionsType: coreClient.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"LifetimeActionsType\",\n    modelProperties: {\n      type: {\n        serializedName: \"type\",\n        type: {\n          name: \"Enum\",\n          allowedValues: [\"Rotate\", \"Notify\"]\n        }\n      }\n    }\n  }\n};\n\nexport const KeyRotationPolicyAttributes: coreClient.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"KeyRotationPolicyAttributes\",\n    modelProperties: {\n      expiryTime: {\n        serializedName: \"expiryTime\",\n        type: {\n          name: \"String\"\n        }\n      },\n      created: {\n        serializedName: \"created\",\n        readOnly: true,\n        type: {\n          name: \"UnixTime\"\n        }\n      },\n      updated: {\n        serializedName: \"updated\",\n        readOnly: true,\n        type: {\n          name: \"UnixTime\"\n        }\n      }\n    }\n  }\n};\n\nexport const GetRandomBytesRequest: coreClient.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"GetRandomBytesRequest\",\n    modelProperties: {\n      count: {\n        constraints: {\n          InclusiveMaximum: 128,\n          InclusiveMinimum: 1\n        },\n        serializedName: \"count\",\n        required: true,\n        type: {\n          name: \"Number\"\n        }\n      }\n    }\n  }\n};\n\nexport const RandomBytes: coreClient.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"RandomBytes\",\n    modelProperties: {\n      value: {\n        serializedName: \"value\",\n        required: true,\n        type: {\n          name: \"Base64Url\"\n        }\n      }\n    }\n  }\n};\n\nexport const KeyProperties: coreClient.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"KeyProperties\",\n    modelProperties: {\n      exportable: {\n        serializedName: \"exportable\",\n        type: {\n          name: \"Boolean\"\n        }\n      },\n      keyType: {\n        serializedName: \"kty\",\n        type: {\n          name: \"String\"\n        }\n      },\n      keySize: {\n        serializedName: \"key_size\",\n        type: {\n          name: \"Number\"\n        }\n      },\n      reuseKey: {\n        serializedName: \"reuse_key\",\n        type: {\n          name: \"Boolean\"\n        }\n      },\n      curve: {\n        serializedName: \"crv\",\n        type: {\n          name: \"String\"\n        }\n      }\n    }\n  }\n};\n\nexport const KeyExportParameters: coreClient.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"KeyExportParameters\",\n    modelProperties: {\n      wrappingKey: {\n        serializedName: \"wrappingKey\",\n        type: {\n          name: \"Composite\",\n          className: \"JsonWebKey\"\n        }\n      },\n      wrappingKid: {\n        serializedName: \"wrappingKid\",\n        type: {\n          name: \"String\"\n        }\n      },\n      enc: {\n        serializedName: \"enc\",\n        type: {\n          name: \"String\"\n        }\n      }\n    }\n  }\n};\n\nexport const KeyAttributes: coreClient.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"KeyAttributes\",\n    modelProperties: {\n      ...Attributes.type.modelProperties,\n      recoverableDays: {\n        serializedName: \"recoverableDays\",\n        readOnly: true,\n        type: {\n          name: \"Number\"\n        }\n      },\n      recoveryLevel: {\n        serializedName: \"recoveryLevel\",\n        readOnly: true,\n        type: {\n          name: \"String\"\n        }\n      },\n      exportable: {\n        serializedName: \"exportable\",\n        type: {\n          name: \"Boolean\"\n        }\n      }\n    }\n  }\n};\n\nexport const DeletedKeyBundle: coreClient.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"DeletedKeyBundle\",\n    modelProperties: {\n      ...KeyBundle.type.modelProperties,\n      recoveryId: {\n        serializedName: \"recoveryId\",\n        type: {\n          name: \"String\"\n        }\n      },\n      scheduledPurgeDate: {\n        serializedName: \"scheduledPurgeDate\",\n        readOnly: true,\n        type: {\n          name: \"UnixTime\"\n        }\n      },\n      deletedDate: {\n        serializedName: \"deletedDate\",\n        readOnly: true,\n        type: {\n          name: \"UnixTime\"\n        }\n      }\n    }\n  }\n};\n\nexport const DeletedKeyItem: coreClient.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"DeletedKeyItem\",\n    modelProperties: {\n      ...KeyItem.type.modelProperties,\n      recoveryId: {\n        serializedName: \"recoveryId\",\n        type: {\n          name: \"String\"\n        }\n      },\n      scheduledPurgeDate: {\n        serializedName: \"scheduledPurgeDate\",\n        readOnly: true,\n        type: {\n          name: \"UnixTime\"\n        }\n      },\n      deletedDate: {\n        serializedName: \"deletedDate\",\n        readOnly: true,\n        type: {\n          name: \"UnixTime\"\n        }\n      }\n    }\n  }\n};\n","/*\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT License.\n *\n * Code generated by Microsoft (R) AutoRest Code Generator.\n * Changes may cause incorrect behavior and will be lost if the code is regenerated.\n */\n\nimport {\n  OperationParameter,\n  OperationURLParameter,\n  OperationQueryParameter\n} from \"@azure/core-client\";\nimport {\n  KeyCreateParameters as KeyCreateParametersMapper,\n  KeyImportParameters as KeyImportParametersMapper,\n  KeyUpdateParameters as KeyUpdateParametersMapper,\n  KeyRestoreParameters as KeyRestoreParametersMapper,\n  KeyOperationsParameters as KeyOperationsParametersMapper,\n  KeySignParameters as KeySignParametersMapper,\n  KeyVerifyParameters as KeyVerifyParametersMapper,\n  KeyReleaseParameters as KeyReleaseParametersMapper,\n  KeyRotationPolicy as KeyRotationPolicyMapper,\n  GetRandomBytesRequest as GetRandomBytesRequestMapper\n} from \"../models/mappers\";\n\nexport const contentType: OperationParameter = {\n  parameterPath: [\"options\", \"contentType\"],\n  mapper: {\n    defaultValue: \"application/json\",\n    isConstant: true,\n    serializedName: \"Content-Type\",\n    type: {\n      name: \"String\"\n    }\n  }\n};\n\nexport const accept: OperationParameter = {\n  parameterPath: \"accept\",\n  mapper: {\n    defaultValue: \"application/json\",\n    isConstant: true,\n    serializedName: \"Accept\",\n    type: {\n      name: \"String\"\n    }\n  }\n};\n\nexport const kty: OperationParameter = {\n  parameterPath: \"kty\",\n  mapper: KeyCreateParametersMapper\n};\n\nexport const keySize: OperationParameter = {\n  parameterPath: [\"options\", \"keySize\"],\n  mapper: KeyCreateParametersMapper\n};\n\nexport const publicExponent: OperationParameter = {\n  parameterPath: [\"options\", \"publicExponent\"],\n  mapper: KeyCreateParametersMapper\n};\n\nexport const keyOps: OperationParameter = {\n  parameterPath: [\"options\", \"keyOps\"],\n  mapper: KeyCreateParametersMapper\n};\n\nexport const keyAttributes: OperationParameter = {\n  parameterPath: [\"options\", \"keyAttributes\"],\n  mapper: KeyCreateParametersMapper\n};\n\nexport const tags: OperationParameter = {\n  parameterPath: [\"options\", \"tags\"],\n  mapper: KeyCreateParametersMapper\n};\n\nexport const curve: OperationParameter = {\n  parameterPath: [\"options\", \"curve\"],\n  mapper: KeyCreateParametersMapper\n};\n\nexport const releasePolicy: OperationParameter = {\n  parameterPath: [\"options\", \"releasePolicy\"],\n  mapper: KeyCreateParametersMapper\n};\n\nexport const vaultBaseUrl: OperationURLParameter = {\n  parameterPath: \"vaultBaseUrl\",\n  mapper: {\n    serializedName: \"vaultBaseUrl\",\n    required: true,\n    type: {\n      name: \"String\"\n    }\n  },\n  skipEncoding: true\n};\n\nexport const keyName: OperationURLParameter = {\n  parameterPath: \"keyName\",\n  mapper: {\n    constraints: {\n      Pattern: new RegExp(\"^[0-9a-zA-Z-]+$\")\n    },\n    serializedName: \"key-name\",\n    required: true,\n    type: {\n      name: \"String\"\n    }\n  }\n};\n\nexport const apiVersion: OperationQueryParameter = {\n  parameterPath: \"apiVersion\",\n  mapper: {\n    serializedName: \"api-version\",\n    required: true,\n    type: {\n      name: \"String\"\n    }\n  }\n};\n\nexport const hsm: OperationParameter = {\n  parameterPath: [\"options\", \"hsm\"],\n  mapper: KeyImportParametersMapper\n};\n\nexport const key: OperationParameter = {\n  parameterPath: \"key\",\n  mapper: KeyImportParametersMapper\n};\n\nexport const keyAttributes1: OperationParameter = {\n  parameterPath: [\"options\", \"keyAttributes\"],\n  mapper: KeyImportParametersMapper\n};\n\nexport const tags1: OperationParameter = {\n  parameterPath: [\"options\", \"tags\"],\n  mapper: KeyImportParametersMapper\n};\n\nexport const releasePolicy1: OperationParameter = {\n  parameterPath: [\"options\", \"releasePolicy\"],\n  mapper: KeyImportParametersMapper\n};\n\nexport const keyName1: OperationURLParameter = {\n  parameterPath: \"keyName\",\n  mapper: {\n    serializedName: \"key-name\",\n    required: true,\n    type: {\n      name: \"String\"\n    }\n  }\n};\n\nexport const keyOps1: OperationParameter = {\n  parameterPath: [\"options\", \"keyOps\"],\n  mapper: KeyUpdateParametersMapper\n};\n\nexport const keyAttributes2: OperationParameter = {\n  parameterPath: [\"options\", \"keyAttributes\"],\n  mapper: KeyUpdateParametersMapper\n};\n\nexport const tags2: OperationParameter = {\n  parameterPath: [\"options\", \"tags\"],\n  mapper: KeyUpdateParametersMapper\n};\n\nexport const releasePolicy2: OperationParameter = {\n  parameterPath: [\"options\", \"releasePolicy\"],\n  mapper: KeyUpdateParametersMapper\n};\n\nexport const keyVersion: OperationURLParameter = {\n  parameterPath: \"keyVersion\",\n  mapper: {\n    serializedName: \"key-version\",\n    required: true,\n    type: {\n      name: \"String\"\n    }\n  }\n};\n\nexport const maxresults: OperationQueryParameter = {\n  parameterPath: [\"options\", \"maxresults\"],\n  mapper: {\n    constraints: {\n      InclusiveMaximum: 25,\n      InclusiveMinimum: 1\n    },\n    serializedName: \"maxresults\",\n    type: {\n      name: \"Number\"\n    }\n  }\n};\n\nexport const keyBundleBackup: OperationParameter = {\n  parameterPath: \"keyBundleBackup\",\n  mapper: KeyRestoreParametersMapper\n};\n\nexport const algorithm: OperationParameter = {\n  parameterPath: \"algorithm\",\n  mapper: KeyOperationsParametersMapper\n};\n\nexport const value: OperationParameter = {\n  parameterPath: \"value\",\n  mapper: KeyOperationsParametersMapper\n};\n\nexport const iv: OperationParameter = {\n  parameterPath: [\"options\", \"iv\"],\n  mapper: KeyOperationsParametersMapper\n};\n\nexport const additionalAuthenticatedData: OperationParameter = {\n  parameterPath: [\"options\", \"additionalAuthenticatedData\"],\n  mapper: KeyOperationsParametersMapper\n};\n\nexport const authenticationTag: OperationParameter = {\n  parameterPath: [\"options\", \"authenticationTag\"],\n  mapper: KeyOperationsParametersMapper\n};\n\nexport const algorithm1: OperationParameter = {\n  parameterPath: \"algorithm\",\n  mapper: KeySignParametersMapper\n};\n\nexport const value1: OperationParameter = {\n  parameterPath: \"value\",\n  mapper: KeySignParametersMapper\n};\n\nexport const algorithm2: OperationParameter = {\n  parameterPath: \"algorithm\",\n  mapper: KeyVerifyParametersMapper\n};\n\nexport const digest: OperationParameter = {\n  parameterPath: \"digest\",\n  mapper: KeyVerifyParametersMapper\n};\n\nexport const signature: OperationParameter = {\n  parameterPath: \"signature\",\n  mapper: KeyVerifyParametersMapper\n};\n\nexport const targetAttestationToken: OperationParameter = {\n  parameterPath: \"targetAttestationToken\",\n  mapper: KeyReleaseParametersMapper\n};\n\nexport const nonce: OperationParameter = {\n  parameterPath: [\"options\", \"nonce\"],\n  mapper: KeyReleaseParametersMapper\n};\n\nexport const enc: OperationParameter = {\n  parameterPath: [\"options\", \"enc\"],\n  mapper: KeyReleaseParametersMapper\n};\n\nexport const keyRotationPolicy: OperationParameter = {\n  parameterPath: \"keyRotationPolicy\",\n  mapper: KeyRotationPolicyMapper\n};\n\nexport const count: OperationParameter = {\n  parameterPath: \"count\",\n  mapper: GetRandomBytesRequestMapper\n};\n\nexport const nextLink: OperationURLParameter = {\n  parameterPath: \"nextLink\",\n  mapper: {\n    serializedName: \"nextLink\",\n    required: true,\n    type: {\n      name: \"String\"\n    }\n  },\n  skipEncoding: true\n};\n","/*\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT License.\n *\n * Code generated by Microsoft (R) AutoRest Code Generator.\n * Changes may cause incorrect behavior and will be lost if the code is regenerated.\n */\n\nimport * as coreClient from \"@azure/core-client\";\nimport * as coreHttpCompat from \"@azure/core-http-compat\";\nimport * as coreRestPipeline from \"@azure/core-rest-pipeline\";\nimport * as Parameters from \"./models/parameters\";\nimport * as Mappers from \"./models/mappers\";\nimport {\n  ApiVersion74,\n  KeyVaultClientOptionalParams,\n  JsonWebKeyType,\n  CreateKeyOptionalParams,\n  CreateKeyResponse,\n  RotateKeyOptionalParams,\n  RotateKeyResponse,\n  JsonWebKey,\n  ImportKeyOptionalParams,\n  ImportKeyResponse,\n  DeleteKeyOptionalParams,\n  DeleteKeyResponse,\n  UpdateKeyOptionalParams,\n  UpdateKeyResponse,\n  GetKeyOptionalParams,\n  GetKeyResponse,\n  GetKeyVersionsOptionalParams,\n  GetKeyVersionsResponse,\n  GetKeysOptionalParams,\n  GetKeysResponse,\n  BackupKeyOptionalParams,\n  BackupKeyResponse,\n  RestoreKeyOptionalParams,\n  RestoreKeyResponse,\n  JsonWebKeyEncryptionAlgorithm,\n  EncryptOptionalParams,\n  EncryptResponse,\n  DecryptOptionalParams,\n  DecryptResponse,\n  JsonWebKeySignatureAlgorithm,\n  SignOptionalParams,\n  SignResponse,\n  VerifyOptionalParams,\n  VerifyResponse,\n  WrapKeyOptionalParams,\n  WrapKeyResponse,\n  UnwrapKeyOptionalParams,\n  UnwrapKeyResponse,\n  ReleaseOptionalParams,\n  ReleaseResponse,\n  GetDeletedKeysOptionalParams,\n  GetDeletedKeysResponse,\n  GetDeletedKeyOptionalParams,\n  GetDeletedKeyResponse,\n  PurgeDeletedKeyOptionalParams,\n  RecoverDeletedKeyOptionalParams,\n  RecoverDeletedKeyResponse,\n  GetKeyRotationPolicyOptionalParams,\n  GetKeyRotationPolicyResponse,\n  KeyRotationPolicy,\n  UpdateKeyRotationPolicyOptionalParams,\n  UpdateKeyRotationPolicyResponse,\n  GetRandomBytesOptionalParams,\n  GetRandomBytesResponse,\n  GetKeyVersionsNextOptionalParams,\n  GetKeyVersionsNextResponse,\n  GetKeysNextOptionalParams,\n  GetKeysNextResponse,\n  GetDeletedKeysNextOptionalParams,\n  GetDeletedKeysNextResponse\n} from \"./models\";\n\nexport class KeyVaultClient extends coreHttpCompat.ExtendedServiceClient {\n  apiVersion: ApiVersion74;\n\n  /**\n   * Initializes a new instance of the KeyVaultClient class.\n   * @param apiVersion Api Version\n   * @param options The parameter options\n   */\n  constructor(\n    apiVersion: ApiVersion74,\n    options?: KeyVaultClientOptionalParams\n  ) {\n    if (apiVersion === undefined) {\n      throw new Error(\"'apiVersion' cannot be null\");\n    }\n\n    // Initializing default values for options\n    if (!options) {\n      options = {};\n    }\n    const defaults: KeyVaultClientOptionalParams = {\n      requestContentType: \"application/json; charset=utf-8\"\n    };\n\n    const packageDetails = `azsdk-js-keyvault-keys/4.7.0`;\n    const userAgentPrefix =\n      options.userAgentOptions && options.userAgentOptions.userAgentPrefix\n        ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}`\n        : `${packageDetails}`;\n\n    const optionsWithDefaults = {\n      ...defaults,\n      ...options,\n      userAgentOptions: {\n        userAgentPrefix\n      },\n      baseUri: options.endpoint ?? options.baseUri ?? \"{vaultBaseUrl}\"\n    };\n    super(optionsWithDefaults);\n\n    if (options?.pipeline && options.pipeline.getOrderedPolicies().length > 0) {\n      const pipelinePolicies: coreRestPipeline.PipelinePolicy[] = options.pipeline.getOrderedPolicies();\n      const bearerTokenAuthenticationPolicyFound = pipelinePolicies.some(\n        (pipelinePolicy) =>\n          pipelinePolicy.name ===\n          coreRestPipeline.bearerTokenAuthenticationPolicyName\n      );\n      if (!bearerTokenAuthenticationPolicyFound) {\n        this.pipeline.removePolicy({\n          name: coreRestPipeline.bearerTokenAuthenticationPolicyName\n        });\n        this.pipeline.addPolicy(\n          coreRestPipeline.bearerTokenAuthenticationPolicy({\n            scopes: `${optionsWithDefaults.baseUri}/.default`,\n            challengeCallbacks: {\n              authorizeRequestOnChallenge:\n                coreClient.authorizeRequestOnClaimChallenge\n            }\n          })\n        );\n      }\n    }\n    // Parameter assignments\n    this.apiVersion = apiVersion;\n  }\n\n  /**\n   * The create key operation can be used to create any key type in Azure Key Vault. If the named key\n   * already exists, Azure Key Vault creates a new version of the key. It requires the keys/create\n   * permission.\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param keyName The name for the new key. The system will generate the version name for the new key.\n   *                The value you provide may be copied globally for the purpose of running the service. The value\n   *                provided should not include personally identifiable or sensitive information.\n   * @param kty The type of key to create. For valid values, see JsonWebKeyType.\n   * @param options The options parameters.\n   */\n  createKey(\n    vaultBaseUrl: string,\n    keyName: string,\n    kty: JsonWebKeyType,\n    options?: CreateKeyOptionalParams\n  ): Promise<CreateKeyResponse> {\n    return this.sendOperationRequest(\n      { vaultBaseUrl, keyName, kty, options },\n      createKeyOperationSpec\n    );\n  }\n\n  /**\n   * The operation will rotate the key based on the key policy. It requires the keys/rotate permission.\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param keyName The name of key to be rotated. The system will generate a new version in the\n   *                specified key.\n   * @param options The options parameters.\n   */\n  rotateKey(\n    vaultBaseUrl: string,\n    keyName: string,\n    options?: RotateKeyOptionalParams\n  ): Promise<RotateKeyResponse> {\n    return this.sendOperationRequest(\n      { vaultBaseUrl, keyName, options },\n      rotateKeyOperationSpec\n    );\n  }\n\n  /**\n   * The import key operation may be used to import any key type into an Azure Key Vault. If the named\n   * key already exists, Azure Key Vault creates a new version of the key. This operation requires the\n   * keys/import permission.\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param keyName Name for the imported key. The value you provide may be copied globally for the\n   *                purpose of running the service. The value provided should not include personally identifiable or\n   *                sensitive information.\n   * @param key The Json web key\n   * @param options The options parameters.\n   */\n  importKey(\n    vaultBaseUrl: string,\n    keyName: string,\n    key: JsonWebKey,\n    options?: ImportKeyOptionalParams\n  ): Promise<ImportKeyResponse> {\n    return this.sendOperationRequest(\n      { vaultBaseUrl, keyName, key, options },\n      importKeyOperationSpec\n    );\n  }\n\n  /**\n   * The delete key operation cannot be used to remove individual versions of a key. This operation\n   * removes the cryptographic material associated with the key, which means the key is not usable for\n   * Sign/Verify, Wrap/Unwrap or Encrypt/Decrypt operations. This operation requires the keys/delete\n   * permission.\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param keyName The name of the key to delete.\n   * @param options The options parameters.\n   */\n  deleteKey(\n    vaultBaseUrl: string,\n    keyName: string,\n    options?: DeleteKeyOptionalParams\n  ): Promise<DeleteKeyResponse> {\n    return this.sendOperationRequest(\n      { vaultBaseUrl, keyName, options },\n      deleteKeyOperationSpec\n    );\n  }\n\n  /**\n   * In order to perform this operation, the key must already exist in the Key Vault. Note: The\n   * cryptographic material of a key itself cannot be changed. This operation requires the keys/update\n   * permission.\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param keyName The name of key to update.\n   * @param keyVersion The version of the key to update.\n   * @param options The options parameters.\n   */\n  updateKey(\n    vaultBaseUrl: string,\n    keyName: string,\n    keyVersion: string,\n    options?: UpdateKeyOptionalParams\n  ): Promise<UpdateKeyResponse> {\n    return this.sendOperationRequest(\n      { vaultBaseUrl, keyName, keyVersion, options },\n      updateKeyOperationSpec\n    );\n  }\n\n  /**\n   * The get key operation is applicable to all key types. If the requested key is symmetric, then no key\n   * material is released in the response. This operation requires the keys/get permission.\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param keyName The name of the key to get.\n   * @param keyVersion Adding the version parameter retrieves a specific version of a key. This URI\n   *                   fragment is optional. If not specified, the latest version of the key is returned.\n   * @param options The options parameters.\n   */\n  getKey(\n    vaultBaseUrl: string,\n    keyName: string,\n    keyVersion: string,\n    options?: GetKeyOptionalParams\n  ): Promise<GetKeyResponse> {\n    return this.sendOperationRequest(\n      { vaultBaseUrl, keyName, keyVersion, options },\n      getKeyOperationSpec\n    );\n  }\n\n  /**\n   * The full key identifier, attributes, and tags are provided in the response. This operation requires\n   * the keys/list permission.\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param keyName The name of the key.\n   * @param options The options parameters.\n   */\n  getKeyVersions(\n    vaultBaseUrl: string,\n    keyName: string,\n    options?: GetKeyVersionsOptionalParams\n  ): Promise<GetKeyVersionsResponse> {\n    return this.sendOperationRequest(\n      { vaultBaseUrl, keyName, options },\n      getKeyVersionsOperationSpec\n    );\n  }\n\n  /**\n   * Retrieves a list of the keys in the Key Vault as JSON Web Key structures that contain the public\n   * part of a stored key. The LIST operation is applicable to all key types, however only the base key\n   * identifier, attributes, and tags are provided in the response. Individual versions of a key are not\n   * listed in the response. This operation requires the keys/list permission.\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param options The options parameters.\n   */\n  getKeys(\n    vaultBaseUrl: string,\n    options?: GetKeysOptionalParams\n  ): Promise<GetKeysResponse> {\n    return this.sendOperationRequest(\n      { vaultBaseUrl, options },\n      getKeysOperationSpec\n    );\n  }\n\n  /**\n   * The Key Backup operation exports a key from Azure Key Vault in a protected form. Note that this\n   * operation does NOT return key material in a form that can be used outside the Azure Key Vault\n   * system, the returned key material is either protected to a Azure Key Vault HSM or to Azure Key Vault\n   * itself. The intent of this operation is to allow a client to GENERATE a key in one Azure Key Vault\n   * instance, BACKUP the key, and then RESTORE it into another Azure Key Vault instance. The BACKUP\n   * operation may be used to export, in protected form, any key type from Azure Key Vault. Individual\n   * versions of a key cannot be backed up. BACKUP / RESTORE can be performed within geographical\n   * boundaries only; meaning that a BACKUP from one geographical area cannot be restored to another\n   * geographical area. For example, a backup from the US geographical area cannot be restored in an EU\n   * geographical area. This operation requires the key/backup permission.\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param keyName The name of the key.\n   * @param options The options parameters.\n   */\n  backupKey(\n    vaultBaseUrl: string,\n    keyName: string,\n    options?: BackupKeyOptionalParams\n  ): Promise<BackupKeyResponse> {\n    return this.sendOperationRequest(\n      { vaultBaseUrl, keyName, options },\n      backupKeyOperationSpec\n    );\n  }\n\n  /**\n   * Imports a previously backed up key into Azure Key Vault, restoring the key, its key identifier,\n   * attributes and access control policies. The RESTORE operation may be used to import a previously\n   * backed up key. Individual versions of a key cannot be restored. The key is restored in its entirety\n   * with the same key name as it had when it was backed up. If the key name is not available in the\n   * target Key Vault, the RESTORE operation will be rejected. While the key name is retained during\n   * restore, the final key identifier will change if the key is restored to a different vault. Restore\n   * will restore all versions and preserve version identifiers. The RESTORE operation is subject to\n   * security constraints: The target Key Vault must be owned by the same Microsoft Azure Subscription as\n   * the source Key Vault The user must have RESTORE permission in the target Key Vault. This operation\n   * requires the keys/restore permission.\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param keyBundleBackup The backup blob associated with a key bundle.\n   * @param options The options parameters.\n   */\n  restoreKey(\n    vaultBaseUrl: string,\n    keyBundleBackup: Uint8Array,\n    options?: RestoreKeyOptionalParams\n  ): Promise<RestoreKeyResponse> {\n    return this.sendOperationRequest(\n      { vaultBaseUrl, keyBundleBackup, options },\n      restoreKeyOperationSpec\n    );\n  }\n\n  /**\n   * The ENCRYPT operation encrypts an arbitrary sequence of bytes using an encryption key that is stored\n   * in Azure Key Vault. Note that the ENCRYPT operation only supports a single block of data, the size\n   * of which is dependent on the target key and the encryption algorithm to be used. The ENCRYPT\n   * operation is only strictly necessary for symmetric keys stored in Azure Key Vault since protection\n   * with an asymmetric key can be performed using public portion of the key. This operation is supported\n   * for asymmetric keys as a convenience for callers that have a key-reference but do not have access to\n   * the public key material. This operation requires the keys/encrypt permission.\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param keyName The name of the key.\n   * @param keyVersion The version of the key.\n   * @param algorithm algorithm identifier\n   * @param value\n   * @param options The options parameters.\n   */\n  encrypt(\n    vaultBaseUrl: string,\n    keyName: string,\n    keyVersion: string,\n    algorithm: JsonWebKeyEncryptionAlgorithm,\n    value: Uint8Array,\n    options?: EncryptOptionalParams\n  ): Promise<EncryptResponse> {\n    return this.sendOperationRequest(\n      { vaultBaseUrl, keyName, keyVersion, algorithm, value, options },\n      encryptOperationSpec\n    );\n  }\n\n  /**\n   * The DECRYPT operation decrypts a well-formed block of ciphertext using the target encryption key and\n   * specified algorithm. This operation is the reverse of the ENCRYPT operation; only a single block of\n   * data may be decrypted, the size of this block is dependent on the target key and the algorithm to be\n   * used. The DECRYPT operation applies to asymmetric and symmetric keys stored in Azure Key Vault since\n   * it uses the private portion of the key. This operation requires the keys/decrypt permission.\n   * Microsoft recommends not to use CBC algorithms for decryption without first ensuring the integrity\n   * of the ciphertext using an HMAC, for example. See\n   * https://docs.microsoft.com/dotnet/standard/security/vulnerabilities-cbc-mode for more information.\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param keyName The name of the key.\n   * @param keyVersion The version of the key.\n   * @param algorithm algorithm identifier\n   * @param value\n   * @param options The options parameters.\n   */\n  decrypt(\n    vaultBaseUrl: string,\n    keyName: string,\n    keyVersion: string,\n    algorithm: JsonWebKeyEncryptionAlgorithm,\n    value: Uint8Array,\n    options?: DecryptOptionalParams\n  ): Promise<DecryptResponse> {\n    return this.sendOperationRequest(\n      { vaultBaseUrl, keyName, keyVersion, algorithm, value, options },\n      decryptOperationSpec\n    );\n  }\n\n  /**\n   * The SIGN operation is applicable to asymmetric and symmetric keys stored in Azure Key Vault since\n   * this operation uses the private portion of the key. This operation requires the keys/sign\n   * permission.\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param keyName The name of the key.\n   * @param keyVersion The version of the key.\n   * @param algorithm The signing/verification algorithm identifier. For more information on possible\n   *                  algorithm types, see JsonWebKeySignatureAlgorithm.\n   * @param value\n   * @param options The options parameters.\n   */\n  sign(\n    vaultBaseUrl: string,\n    keyName: string,\n    keyVersion: string,\n    algorithm: JsonWebKeySignatureAlgorithm,\n    value: Uint8Array,\n    options?: SignOptionalParams\n  ): Promise<SignResponse> {\n    return this.sendOperationRequest(\n      { vaultBaseUrl, keyName, keyVersion, algorithm, value, options },\n      signOperationSpec\n    );\n  }\n\n  /**\n   * The VERIFY operation is applicable to symmetric keys stored in Azure Key Vault. VERIFY is not\n   * strictly necessary for asymmetric keys stored in Azure Key Vault since signature verification can be\n   * performed using the public portion of the key but this operation is supported as a convenience for\n   * callers that only have a key-reference and not the public portion of the key. This operation\n   * requires the keys/verify permission.\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param keyName The name of the key.\n   * @param keyVersion The version of the key.\n   * @param algorithm The signing/verification algorithm. For more information on possible algorithm\n   *                  types, see JsonWebKeySignatureAlgorithm.\n   * @param digest The digest used for signing.\n   * @param signature The signature to be verified.\n   * @param options The options parameters.\n   */\n  verify(\n    vaultBaseUrl: string,\n    keyName: string,\n    keyVersion: string,\n    algorithm: JsonWebKeySignatureAlgorithm,\n    digest: Uint8Array,\n    signature: Uint8Array,\n    options?: VerifyOptionalParams\n  ): Promise<VerifyResponse> {\n    return this.sendOperationRequest(\n      {\n        vaultBaseUrl,\n        keyName,\n        keyVersion,\n        algorithm,\n        digest,\n        signature,\n        options\n      },\n      verifyOperationSpec\n    );\n  }\n\n  /**\n   * The WRAP operation supports encryption of a symmetric key using a key encryption key that has\n   * previously been stored in an Azure Key Vault. The WRAP operation is only strictly necessary for\n   * symmetric keys stored in Azure Key Vault since protection with an asymmetric key can be performed\n   * using the public portion of the key. This operation is supported for asymmetric keys as a\n   * convenience for callers that have a key-reference but do not have access to the public key material.\n   * This operation requires the keys/wrapKey permission.\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param keyName The name of the key.\n   * @param keyVersion The version of the key.\n   * @param algorithm algorithm identifier\n   * @param value\n   * @param options The options parameters.\n   */\n  wrapKey(\n    vaultBaseUrl: string,\n    keyName: string,\n    keyVersion: string,\n    algorithm: JsonWebKeyEncryptionAlgorithm,\n    value: Uint8Array,\n    options?: WrapKeyOptionalParams\n  ): Promise<WrapKeyResponse> {\n    return this.sendOperationRequest(\n      { vaultBaseUrl, keyName, keyVersion, algorithm, value, options },\n      wrapKeyOperationSpec\n    );\n  }\n\n  /**\n   * The UNWRAP operation supports decryption of a symmetric key using the target key encryption key.\n   * This operation is the reverse of the WRAP operation. The UNWRAP operation applies to asymmetric and\n   * symmetric keys stored in Azure Key Vault since it uses the private portion of the key. This\n   * operation requires the keys/unwrapKey permission.\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param keyName The name of the key.\n   * @param keyVersion The version of the key.\n   * @param algorithm algorithm identifier\n   * @param value\n   * @param options The options parameters.\n   */\n  unwrapKey(\n    vaultBaseUrl: string,\n    keyName: string,\n    keyVersion: string,\n    algorithm: JsonWebKeyEncryptionAlgorithm,\n    value: Uint8Array,\n    options?: UnwrapKeyOptionalParams\n  ): Promise<UnwrapKeyResponse> {\n    return this.sendOperationRequest(\n      { vaultBaseUrl, keyName, keyVersion, algorithm, value, options },\n      unwrapKeyOperationSpec\n    );\n  }\n\n  /**\n   * The release key operation is applicable to all key types. The target key must be marked exportable.\n   * This operation requires the keys/release permission.\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param keyName The name of the key to get.\n   * @param keyVersion Adding the version parameter retrieves a specific version of a key.\n   * @param targetAttestationToken The attestation assertion for the target of the key release.\n   * @param options The options parameters.\n   */\n  release(\n    vaultBaseUrl: string,\n    keyName: string,\n    keyVersion: string,\n    targetAttestationToken: string,\n    options?: ReleaseOptionalParams\n  ): Promise<ReleaseResponse> {\n    return this.sendOperationRequest(\n      { vaultBaseUrl, keyName, keyVersion, targetAttestationToken, options },\n      releaseOperationSpec\n    );\n  }\n\n  /**\n   * Retrieves a list of the keys in the Key Vault as JSON Web Key structures that contain the public\n   * part of a deleted key. This operation includes deletion-specific information. The Get Deleted Keys\n   * operation is applicable for vaults enabled for soft-delete. While the operation can be invoked on\n   * any vault, it will return an error if invoked on a non soft-delete enabled vault. This operation\n   * requires the keys/list permission.\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param options The options parameters.\n   */\n  getDeletedKeys(\n    vaultBaseUrl: string,\n    options?: GetDeletedKeysOptionalParams\n  ): Promise<GetDeletedKeysResponse> {\n    return this.sendOperationRequest(\n      { vaultBaseUrl, options },\n      getDeletedKeysOperationSpec\n    );\n  }\n\n  /**\n   * The Get Deleted Key operation is applicable for soft-delete enabled vaults. While the operation can\n   * be invoked on any vault, it will return an error if invoked on a non soft-delete enabled vault. This\n   * operation requires the keys/get permission.\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param keyName The name of the key.\n   * @param options The options parameters.\n   */\n  getDeletedKey(\n    vaultBaseUrl: string,\n    keyName: string,\n    options?: GetDeletedKeyOptionalParams\n  ): Promise<GetDeletedKeyResponse> {\n    return this.sendOperationRequest(\n      { vaultBaseUrl, keyName, options },\n      getDeletedKeyOperationSpec\n    );\n  }\n\n  /**\n   * The Purge Deleted Key operation is applicable for soft-delete enabled vaults. While the operation\n   * can be invoked on any vault, it will return an error if invoked on a non soft-delete enabled vault.\n   * This operation requires the keys/purge permission.\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param keyName The name of the key\n   * @param options The options parameters.\n   */\n  purgeDeletedKey(\n    vaultBaseUrl: string,\n    keyName: string,\n    options?: PurgeDeletedKeyOptionalParams\n  ): Promise<void> {\n    return this.sendOperationRequest(\n      { vaultBaseUrl, keyName, options },\n      purgeDeletedKeyOperationSpec\n    );\n  }\n\n  /**\n   * The Recover Deleted Key operation is applicable for deleted keys in soft-delete enabled vaults. It\n   * recovers the deleted key back to its latest version under /keys. An attempt to recover an\n   * non-deleted key will return an error. Consider this the inverse of the delete operation on\n   * soft-delete enabled vaults. This operation requires the keys/recover permission.\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param keyName The name of the deleted key.\n   * @param options The options parameters.\n   */\n  recoverDeletedKey(\n    vaultBaseUrl: string,\n    keyName: string,\n    options?: RecoverDeletedKeyOptionalParams\n  ): Promise<RecoverDeletedKeyResponse> {\n    return this.sendOperationRequest(\n      { vaultBaseUrl, keyName, options },\n      recoverDeletedKeyOperationSpec\n    );\n  }\n\n  /**\n   * The GetKeyRotationPolicy operation returns the specified key policy resources in the specified key\n   * vault. This operation requires the keys/get permission.\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param keyName The name of the key in a given key vault.\n   * @param options The options parameters.\n   */\n  getKeyRotationPolicy(\n    vaultBaseUrl: string,\n    keyName: string,\n    options?: GetKeyRotationPolicyOptionalParams\n  ): Promise<GetKeyRotationPolicyResponse> {\n    return this.sendOperationRequest(\n      { vaultBaseUrl, keyName, options },\n      getKeyRotationPolicyOperationSpec\n    );\n  }\n\n  /**\n   * Set specified members in the key policy. Leave others as undefined. This operation requires the\n   * keys/update permission.\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param keyName The name of the key in the given vault.\n   * @param keyRotationPolicy The policy for the key.\n   * @param options The options parameters.\n   */\n  updateKeyRotationPolicy(\n    vaultBaseUrl: string,\n    keyName: string,\n    keyRotationPolicy: KeyRotationPolicy,\n    options?: UpdateKeyRotationPolicyOptionalParams\n  ): Promise<UpdateKeyRotationPolicyResponse> {\n    return this.sendOperationRequest(\n      { vaultBaseUrl, keyName, keyRotationPolicy, options },\n      updateKeyRotationPolicyOperationSpec\n    );\n  }\n\n  /**\n   * Get the requested number of bytes containing random values from a managed HSM.\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param count The requested number of random bytes.\n   * @param options The options parameters.\n   */\n  getRandomBytes(\n    vaultBaseUrl: string,\n    count: number,\n    options?: GetRandomBytesOptionalParams\n  ): Promise<GetRandomBytesResponse> {\n    return this.sendOperationRequest(\n      { vaultBaseUrl, count, options },\n      getRandomBytesOperationSpec\n    );\n  }\n\n  /**\n   * GetKeyVersionsNext\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param keyName The name of the key.\n   * @param nextLink The nextLink from the previous successful call to the GetKeyVersions method.\n   * @param options The options parameters.\n   */\n  getKeyVersionsNext(\n    vaultBaseUrl: string,\n    keyName: string,\n    nextLink: string,\n    options?: GetKeyVersionsNextOptionalParams\n  ): Promise<GetKeyVersionsNextResponse> {\n    return this.sendOperationRequest(\n      { vaultBaseUrl, keyName, nextLink, options },\n      getKeyVersionsNextOperationSpec\n    );\n  }\n\n  /**\n   * GetKeysNext\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param nextLink The nextLink from the previous successful call to the GetKeys method.\n   * @param options The options parameters.\n   */\n  getKeysNext(\n    vaultBaseUrl: string,\n    nextLink: string,\n    options?: GetKeysNextOptionalParams\n  ): Promise<GetKeysNextResponse> {\n    return this.sendOperationRequest(\n      { vaultBaseUrl, nextLink, options },\n      getKeysNextOperationSpec\n    );\n  }\n\n  /**\n   * GetDeletedKeysNext\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param nextLink The nextLink from the previous successful call to the GetDeletedKeys method.\n   * @param options The options parameters.\n   */\n  getDeletedKeysNext(\n    vaultBaseUrl: string,\n    nextLink: string,\n    options?: GetDeletedKeysNextOptionalParams\n  ): Promise<GetDeletedKeysNextResponse> {\n    return this.sendOperationRequest(\n      { vaultBaseUrl, nextLink, options },\n      getDeletedKeysNextOperationSpec\n    );\n  }\n}\n// Operation Specifications\nconst serializer = coreClient.createSerializer(Mappers, /* isXml */ false);\n\nconst createKeyOperationSpec: coreClient.OperationSpec = {\n  path: \"/keys/{key-name}/create\",\n  httpMethod: \"POST\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.KeyBundle\n    },\n    default: {\n      bodyMapper: Mappers.KeyVaultError\n    }\n  },\n  requestBody: {\n    parameterPath: {\n      kty: [\"kty\"],\n      keySize: [\"options\", \"keySize\"],\n      publicExponent: [\"options\", \"publicExponent\"],\n      keyOps: [\"options\", \"keyOps\"],\n      keyAttributes: [\"options\", \"keyAttributes\"],\n      tags: [\"options\", \"tags\"],\n      curve: [\"options\", \"curve\"],\n      releasePolicy: [\"options\", \"releasePolicy\"]\n    },\n    mapper: { ...Mappers.KeyCreateParameters, required: true }\n  },\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [Parameters.vaultBaseUrl, Parameters.keyName],\n  headerParameters: [Parameters.contentType, Parameters.accept],\n  mediaType: \"json\",\n  serializer\n};\nconst rotateKeyOperationSpec: coreClient.OperationSpec = {\n  path: \"/keys/{key-name}/rotate\",\n  httpMethod: \"POST\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.KeyBundle\n    },\n    default: {\n      bodyMapper: Mappers.KeyVaultError\n    }\n  },\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [Parameters.vaultBaseUrl, Parameters.keyName],\n  headerParameters: [Parameters.accept],\n  serializer\n};\nconst importKeyOperationSpec: coreClient.OperationSpec = {\n  path: \"/keys/{key-name}\",\n  httpMethod: \"PUT\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.KeyBundle\n    },\n    default: {\n      bodyMapper: Mappers.KeyVaultError\n    }\n  },\n  requestBody: {\n    parameterPath: {\n      hsm: [\"options\", \"hsm\"],\n      key: [\"key\"],\n      keyAttributes: [\"options\", \"keyAttributes\"],\n      tags: [\"options\", \"tags\"],\n      releasePolicy: [\"options\", \"releasePolicy\"]\n    },\n    mapper: { ...Mappers.KeyImportParameters, required: true }\n  },\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [Parameters.vaultBaseUrl, Parameters.keyName],\n  headerParameters: [Parameters.contentType, Parameters.accept],\n  mediaType: \"json\",\n  serializer\n};\nconst deleteKeyOperationSpec: coreClient.OperationSpec = {\n  path: \"/keys/{key-name}\",\n  httpMethod: \"DELETE\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.DeletedKeyBundle\n    },\n    default: {\n      bodyMapper: Mappers.KeyVaultError\n    }\n  },\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [Parameters.vaultBaseUrl, Parameters.keyName1],\n  headerParameters: [Parameters.accept],\n  serializer\n};\nconst updateKeyOperationSpec: coreClient.OperationSpec = {\n  path: \"/keys/{key-name}/{key-version}\",\n  httpMethod: \"PATCH\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.KeyBundle\n    },\n    default: {\n      bodyMapper: Mappers.KeyVaultError\n    }\n  },\n  requestBody: {\n    parameterPath: {\n      keyOps: [\"options\", \"keyOps\"],\n      keyAttributes: [\"options\", \"keyAttributes\"],\n      tags: [\"options\", \"tags\"],\n      releasePolicy: [\"options\", \"releasePolicy\"]\n    },\n    mapper: { ...Mappers.KeyUpdateParameters, required: true }\n  },\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [\n    Parameters.vaultBaseUrl,\n    Parameters.keyName1,\n    Parameters.keyVersion\n  ],\n  headerParameters: [Parameters.contentType, Parameters.accept],\n  mediaType: \"json\",\n  serializer\n};\nconst getKeyOperationSpec: coreClient.OperationSpec = {\n  path: \"/keys/{key-name}/{key-version}\",\n  httpMethod: \"GET\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.KeyBundle\n    },\n    default: {\n      bodyMapper: Mappers.KeyVaultError\n    }\n  },\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [\n    Parameters.vaultBaseUrl,\n    Parameters.keyName1,\n    Parameters.keyVersion\n  ],\n  headerParameters: [Parameters.accept],\n  serializer\n};\nconst getKeyVersionsOperationSpec: coreClient.OperationSpec = {\n  path: \"/keys/{key-name}/versions\",\n  httpMethod: \"GET\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.KeyListResult\n    },\n    default: {\n      bodyMapper: Mappers.KeyVaultError\n    }\n  },\n  queryParameters: [Parameters.apiVersion, Parameters.maxresults],\n  urlParameters: [Parameters.vaultBaseUrl, Parameters.keyName1],\n  headerParameters: [Parameters.accept],\n  serializer\n};\nconst getKeysOperationSpec: coreClient.OperationSpec = {\n  path: \"/keys\",\n  httpMethod: \"GET\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.KeyListResult\n    },\n    default: {\n      bodyMapper: Mappers.KeyVaultError\n    }\n  },\n  queryParameters: [Parameters.apiVersion, Parameters.maxresults],\n  urlParameters: [Parameters.vaultBaseUrl],\n  headerParameters: [Parameters.accept],\n  serializer\n};\nconst backupKeyOperationSpec: coreClient.OperationSpec = {\n  path: \"/keys/{key-name}/backup\",\n  httpMethod: \"POST\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.BackupKeyResult\n    },\n    default: {\n      bodyMapper: Mappers.KeyVaultError\n    }\n  },\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [Parameters.vaultBaseUrl, Parameters.keyName1],\n  headerParameters: [Parameters.accept],\n  serializer\n};\nconst restoreKeyOperationSpec: coreClient.OperationSpec = {\n  path: \"/keys/restore\",\n  httpMethod: \"POST\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.KeyBundle\n    },\n    default: {\n      bodyMapper: Mappers.KeyVaultError\n    }\n  },\n  requestBody: {\n    parameterPath: { keyBundleBackup: [\"keyBundleBackup\"] },\n    mapper: { ...Mappers.KeyRestoreParameters, required: true }\n  },\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [Parameters.vaultBaseUrl],\n  headerParameters: [Parameters.contentType, Parameters.accept],\n  mediaType: \"json\",\n  serializer\n};\nconst encryptOperationSpec: coreClient.OperationSpec = {\n  path: \"/keys/{key-name}/{key-version}/encrypt\",\n  httpMethod: \"POST\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.KeyOperationResult\n    },\n    default: {\n      bodyMapper: Mappers.KeyVaultError\n    }\n  },\n  requestBody: {\n    parameterPath: {\n      algorithm: [\"algorithm\"],\n      value: [\"value\"],\n      iv: [\"options\", \"iv\"],\n      additionalAuthenticatedData: [\"options\", \"additionalAuthenticatedData\"],\n      authenticationTag: [\"options\", \"authenticationTag\"]\n    },\n    mapper: { ...Mappers.KeyOperationsParameters, required: true }\n  },\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [\n    Parameters.vaultBaseUrl,\n    Parameters.keyName1,\n    Parameters.keyVersion\n  ],\n  headerParameters: [Parameters.contentType, Parameters.accept],\n  mediaType: \"json\",\n  serializer\n};\nconst decryptOperationSpec: coreClient.OperationSpec = {\n  path: \"/keys/{key-name}/{key-version}/decrypt\",\n  httpMethod: \"POST\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.KeyOperationResult\n    },\n    default: {\n      bodyMapper: Mappers.KeyVaultError\n    }\n  },\n  requestBody: {\n    parameterPath: {\n      algorithm: [\"algorithm\"],\n      value: [\"value\"],\n      iv: [\"options\", \"iv\"],\n      additionalAuthenticatedData: [\"options\", \"additionalAuthenticatedData\"],\n      authenticationTag: [\"options\", \"authenticationTag\"]\n    },\n    mapper: { ...Mappers.KeyOperationsParameters, required: true }\n  },\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [\n    Parameters.vaultBaseUrl,\n    Parameters.keyName1,\n    Parameters.keyVersion\n  ],\n  headerParameters: [Parameters.contentType, Parameters.accept],\n  mediaType: \"json\",\n  serializer\n};\nconst signOperationSpec: coreClient.OperationSpec = {\n  path: \"/keys/{key-name}/{key-version}/sign\",\n  httpMethod: \"POST\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.KeyOperationResult\n    },\n    default: {\n      bodyMapper: Mappers.KeyVaultError\n    }\n  },\n  requestBody: {\n    parameterPath: { algorithm: [\"algorithm\"], value: [\"value\"] },\n    mapper: { ...Mappers.KeySignParameters, required: true }\n  },\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [\n    Parameters.vaultBaseUrl,\n    Parameters.keyName1,\n    Parameters.keyVersion\n  ],\n  headerParameters: [Parameters.contentType, Parameters.accept],\n  mediaType: \"json\",\n  serializer\n};\nconst verifyOperationSpec: coreClient.OperationSpec = {\n  path: \"/keys/{key-name}/{key-version}/verify\",\n  httpMethod: \"POST\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.KeyVerifyResult\n    },\n    default: {\n      bodyMapper: Mappers.KeyVaultError\n    }\n  },\n  requestBody: {\n    parameterPath: {\n      algorithm: [\"algorithm\"],\n      digest: [\"digest\"],\n      signature: [\"signature\"]\n    },\n    mapper: { ...Mappers.KeyVerifyParameters, required: true }\n  },\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [\n    Parameters.vaultBaseUrl,\n    Parameters.keyName1,\n    Parameters.keyVersion\n  ],\n  headerParameters: [Parameters.contentType, Parameters.accept],\n  mediaType: \"json\",\n  serializer\n};\nconst wrapKeyOperationSpec: coreClient.OperationSpec = {\n  path: \"/keys/{key-name}/{key-version}/wrapkey\",\n  httpMethod: \"POST\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.KeyOperationResult\n    },\n    default: {\n      bodyMapper: Mappers.KeyVaultError\n    }\n  },\n  requestBody: {\n    parameterPath: {\n      algorithm: [\"algorithm\"],\n      value: [\"value\"],\n      iv: [\"options\", \"iv\"],\n      additionalAuthenticatedData: [\"options\", \"additionalAuthenticatedData\"],\n      authenticationTag: [\"options\", \"authenticationTag\"]\n    },\n    mapper: { ...Mappers.KeyOperationsParameters, required: true }\n  },\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [\n    Parameters.vaultBaseUrl,\n    Parameters.keyName1,\n    Parameters.keyVersion\n  ],\n  headerParameters: [Parameters.contentType, Parameters.accept],\n  mediaType: \"json\",\n  serializer\n};\nconst unwrapKeyOperationSpec: coreClient.OperationSpec = {\n  path: \"/keys/{key-name}/{key-version}/unwrapkey\",\n  httpMethod: \"POST\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.KeyOperationResult\n    },\n    default: {\n      bodyMapper: Mappers.KeyVaultError\n    }\n  },\n  requestBody: {\n    parameterPath: {\n      algorithm: [\"algorithm\"],\n      value: [\"value\"],\n      iv: [\"options\", \"iv\"],\n      additionalAuthenticatedData: [\"options\", \"additionalAuthenticatedData\"],\n      authenticationTag: [\"options\", \"authenticationTag\"]\n    },\n    mapper: { ...Mappers.KeyOperationsParameters, required: true }\n  },\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [\n    Parameters.vaultBaseUrl,\n    Parameters.keyName1,\n    Parameters.keyVersion\n  ],\n  headerParameters: [Parameters.contentType, Parameters.accept],\n  mediaType: \"json\",\n  serializer\n};\nconst releaseOperationSpec: coreClient.OperationSpec = {\n  path: \"/keys/{key-name}/{key-version}/release\",\n  httpMethod: \"POST\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.KeyReleaseResult\n    },\n    default: {\n      bodyMapper: Mappers.KeyVaultError\n    }\n  },\n  requestBody: {\n    parameterPath: {\n      targetAttestationToken: [\"targetAttestationToken\"],\n      nonce: [\"options\", \"nonce\"],\n      enc: [\"options\", \"enc\"]\n    },\n    mapper: { ...Mappers.KeyReleaseParameters, required: true }\n  },\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [\n    Parameters.vaultBaseUrl,\n    Parameters.keyName1,\n    Parameters.keyVersion\n  ],\n  headerParameters: [Parameters.contentType, Parameters.accept],\n  mediaType: \"json\",\n  serializer\n};\nconst getDeletedKeysOperationSpec: coreClient.OperationSpec = {\n  path: \"/deletedkeys\",\n  httpMethod: \"GET\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.DeletedKeyListResult\n    },\n    default: {\n      bodyMapper: Mappers.KeyVaultError\n    }\n  },\n  queryParameters: [Parameters.apiVersion, Parameters.maxresults],\n  urlParameters: [Parameters.vaultBaseUrl],\n  headerParameters: [Parameters.accept],\n  serializer\n};\nconst getDeletedKeyOperationSpec: coreClient.OperationSpec = {\n  path: \"/deletedkeys/{key-name}\",\n  httpMethod: \"GET\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.DeletedKeyBundle\n    },\n    default: {\n      bodyMapper: Mappers.KeyVaultError\n    }\n  },\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [Parameters.vaultBaseUrl, Parameters.keyName1],\n  headerParameters: [Parameters.accept],\n  serializer\n};\nconst purgeDeletedKeyOperationSpec: coreClient.OperationSpec = {\n  path: \"/deletedkeys/{key-name}\",\n  httpMethod: \"DELETE\",\n  responses: {\n    204: {},\n    default: {\n      bodyMapper: Mappers.KeyVaultError\n    }\n  },\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [Parameters.vaultBaseUrl, Parameters.keyName1],\n  headerParameters: [Parameters.accept],\n  serializer\n};\nconst recoverDeletedKeyOperationSpec: coreClient.OperationSpec = {\n  path: \"/deletedkeys/{key-name}/recover\",\n  httpMethod: \"POST\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.KeyBundle\n    },\n    default: {\n      bodyMapper: Mappers.KeyVaultError\n    }\n  },\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [Parameters.vaultBaseUrl, Parameters.keyName1],\n  headerParameters: [Parameters.accept],\n  serializer\n};\nconst getKeyRotationPolicyOperationSpec: coreClient.OperationSpec = {\n  path: \"/keys/{key-name}/rotationpolicy\",\n  httpMethod: \"GET\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.KeyRotationPolicy\n    },\n    default: {\n      bodyMapper: Mappers.KeyVaultError\n    }\n  },\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [Parameters.vaultBaseUrl, Parameters.keyName1],\n  headerParameters: [Parameters.accept],\n  serializer\n};\nconst updateKeyRotationPolicyOperationSpec: coreClient.OperationSpec = {\n  path: \"/keys/{key-name}/rotationpolicy\",\n  httpMethod: \"PUT\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.KeyRotationPolicy\n    },\n    default: {\n      bodyMapper: Mappers.KeyVaultError\n    }\n  },\n  requestBody: Parameters.keyRotationPolicy,\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [Parameters.vaultBaseUrl, Parameters.keyName1],\n  headerParameters: [Parameters.contentType, Parameters.accept],\n  mediaType: \"json\",\n  serializer\n};\nconst getRandomBytesOperationSpec: coreClient.OperationSpec = {\n  path: \"/rng\",\n  httpMethod: \"POST\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.RandomBytes\n    },\n    default: {\n      bodyMapper: Mappers.KeyVaultError\n    }\n  },\n  requestBody: {\n    parameterPath: { count: [\"count\"] },\n    mapper: { ...Mappers.GetRandomBytesRequest, required: true }\n  },\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [Parameters.vaultBaseUrl],\n  headerParameters: [Parameters.contentType, Parameters.accept],\n  mediaType: \"json\",\n  serializer\n};\nconst getKeyVersionsNextOperationSpec: coreClient.OperationSpec = {\n  path: \"{nextLink}\",\n  httpMethod: \"GET\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.KeyListResult\n    },\n    default: {\n      bodyMapper: Mappers.KeyVaultError\n    }\n  },\n  queryParameters: [Parameters.apiVersion, Parameters.maxresults],\n  urlParameters: [\n    Parameters.vaultBaseUrl,\n    Parameters.keyName1,\n    Parameters.nextLink\n  ],\n  headerParameters: [Parameters.accept],\n  serializer\n};\nconst getKeysNextOperationSpec: coreClient.OperationSpec = {\n  path: \"{nextLink}\",\n  httpMethod: \"GET\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.KeyListResult\n    },\n    default: {\n      bodyMapper: Mappers.KeyVaultError\n    }\n  },\n  queryParameters: [Parameters.apiVersion, Parameters.maxresults],\n  urlParameters: [Parameters.vaultBaseUrl, Parameters.nextLink],\n  headerParameters: [Parameters.accept],\n  serializer\n};\nconst getDeletedKeysNextOperationSpec: coreClient.OperationSpec = {\n  path: \"{nextLink}\",\n  httpMethod: \"GET\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.DeletedKeyListResult\n    },\n    default: {\n      bodyMapper: Mappers.KeyVaultError\n    }\n  },\n  queryParameters: [Parameters.apiVersion, Parameters.maxresults],\n  urlParameters: [Parameters.vaultBaseUrl, Parameters.nextLink],\n  headerParameters: [Parameters.accept],\n  serializer\n};\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nexport const SDK_VERSION: string = \"4.7.0\";\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\n/**\n * Parameters parsed out of the WWW-Authenticate header value by the parseWWWAuthenticate function.\n */\nexport interface WWWAuthenticate {\n  /**\n   * The authorization parameter, if present.\n   */\n  authorization?: string;\n\n  /**\n   * The authorization_url parameter, if present.\n   */\n  authorization_url?: string;\n\n  /**\n   * The resource parameter, if present.\n   */\n  resource?: string;\n\n  /**\n   * The scope parameter, if present.\n   */\n  scope?: string;\n\n  /**\n   * The tenantId parameter, if present.\n   */\n  tenantId?: string;\n}\n\nconst validWWWAuthenticateProperties: readonly (keyof WWWAuthenticate)[] = [\n  \"authorization\",\n  \"authorization_url\",\n  \"resource\",\n  \"scope\",\n  \"tenantId\",\n] as const;\n\n/**\n * Parses an WWW-Authenticate response header.\n * This transforms a string value like:\n * `Bearer authorization=\"https://some.url/tenantId\", resource=\"https://some.url\"`\n * into an object like:\n * `{ authorization: \"https://some.url/tenantId\", resource: \"https://some.url\" }`\n * @param headerValue - String value in the WWW-Authenticate header\n */\nexport function parseWWWAuthenticateHeader(headerValue: string): WWWAuthenticate {\n  const pairDelimiter = /,? +/;\n  const parsed = headerValue.split(pairDelimiter).reduce<WWWAuthenticate>((kvPairs, p) => {\n    if (p.match(/\\w=\"/)) {\n      // 'sampleKey=\"sample_value\"' -> [sampleKey, \"sample_value\"] -> { sampleKey: sample_value }\n      const [key, value] = p.split(\"=\");\n      if (validWWWAuthenticateProperties.includes(key as keyof WWWAuthenticate)) {\n        // The values will be wrapped in quotes, which need to be stripped out.\n        return { ...kvPairs, [key]: value.slice(1, -1) };\n      }\n    }\n    return kvPairs;\n  }, {});\n\n  // Finally, we pull the tenantId from the authorization header to support multi-tenant authentication.\n  if (parsed.authorization) {\n    try {\n      const tenantId = new URL(parsed.authorization).pathname.substring(1);\n      if (tenantId) {\n        parsed.tenantId = tenantId;\n      }\n    } catch (_) {\n      throw new Error(`The challenge authorization URI '${parsed.authorization}' is invalid.`);\n    }\n  }\n\n  return parsed;\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  AuthorizeRequestOnChallengeOptions,\n  AuthorizeRequestOptions,\n  ChallengeCallbacks,\n  PipelineRequest,\n  RequestBodyType,\n} from \"@azure/core-rest-pipeline\";\nimport { WWWAuthenticate, parseWWWAuthenticateHeader } from \"./parseWWWAuthenticate\";\n\nimport { GetTokenOptions } from \"@azure/core-auth\";\n\n/**\n * @internal\n * Holds the state of Challenge Auth.\n * When making the first request we force Key Vault to begin a challenge\n * by clearing out the request body and storing it locally.\n *\n * Later on, the authorizeRequestOnChallenge callback will process the\n * challenge and, if ready to resend the original request, reset the body\n * so that it may be sent again.\n *\n * Once a client has succeeded once, we can start skipping CAE.\n */\ntype ChallengeState =\n  | {\n      status: \"none\";\n    }\n  | {\n      status: \"started\";\n      originalBody?: RequestBodyType;\n    }\n  | {\n      status: \"complete\";\n      scopes: string[];\n    };\n\n/**\n * Additional options for the challenge based authentication policy.\n */\nexport interface CreateChallengeCallbacksOptions {\n  /**\n   * Whether to disable verification that the challenge resource matches the Key Vault or Managed HSM domain.\n   *\n   * Defaults to false.\n   */\n  disableChallengeResourceVerification?: boolean;\n}\n\nfunction verifyChallengeResource(scope: string, request: PipelineRequest): void {\n  let scopeAsUrl: URL;\n  try {\n    scopeAsUrl = new URL(scope);\n  } catch (e) {\n    throw new Error(`The challenge contains invalid scope '${scope}'`);\n  }\n\n  const requestUrl = new URL(request.url);\n\n  if (!requestUrl.hostname.endsWith(`.${scopeAsUrl.hostname}`)) {\n    throw new Error(\n      `The challenge resource '${scopeAsUrl.hostname}' does not match the requested domain. Set disableChallengeResourceVerification to true in your client options to disable. See https://aka.ms/azsdk/blog/vault-uri for more information.`\n    );\n  }\n}\n\n/**\n * Creates challenge callback handlers to manage CAE lifecycle in Azure Key Vault.\n *\n * Key Vault supports other authentication schemes, but we ensure challenge authentication\n * is used by first sending a copy of the request, without authorization or content.\n *\n * when the challenge is received, it will be authenticated and used to send the original\n * request with authorization.\n *\n * Following the first request of a client, follow-up requests will get the cached token\n * if possible.\n *\n */\nexport function createKeyVaultChallengeCallbacks(\n  options: CreateChallengeCallbacksOptions = {}\n): ChallengeCallbacks {\n  const { disableChallengeResourceVerification } = options;\n  let challengeState: ChallengeState = { status: \"none\" };\n\n  function requestToOptions(request: PipelineRequest): GetTokenOptions {\n    return {\n      abortSignal: request.abortSignal,\n      requestOptions: {\n        timeout: request.timeout > 0 ? request.timeout : undefined,\n      },\n      tracingOptions: request.tracingOptions,\n    };\n  }\n\n  async function authorizeRequest({\n    request,\n    getAccessToken,\n  }: AuthorizeRequestOptions): Promise<void> {\n    const requestOptions: GetTokenOptions = requestToOptions(request);\n\n    switch (challengeState.status) {\n      case \"none\":\n        challengeState = {\n          status: \"started\",\n          originalBody: request.body,\n        };\n        request.body = null;\n        break;\n      case \"started\":\n        break; // Retry, we should not overwrite the original body\n      case \"complete\": {\n        const token = await getAccessToken(challengeState.scopes, requestOptions);\n        if (token) {\n          request.headers.set(\"authorization\", `Bearer ${token.token}`);\n        }\n        break;\n      }\n    }\n    return Promise.resolve();\n  }\n\n  async function authorizeRequestOnChallenge({\n    request,\n    response,\n    getAccessToken,\n  }: AuthorizeRequestOnChallengeOptions): Promise<boolean> {\n    if (request.body === null && challengeState.status === \"started\") {\n      // Reset the original body before doing anything else.\n      // Note: If successful status will be \"complete\", otherwise \"none\" will\n      // restart the process.\n      request.body = challengeState.originalBody;\n    }\n\n    const getTokenOptions = requestToOptions(request);\n\n    const challenge = response.headers.get(\"WWW-Authenticate\");\n    if (!challenge) {\n      throw new Error(\"Missing challenge.\");\n    }\n    const parsedChallenge: WWWAuthenticate = parseWWWAuthenticateHeader(challenge) || {};\n\n    const scope = parsedChallenge.resource\n      ? parsedChallenge.resource + \"/.default\"\n      : parsedChallenge.scope;\n\n    if (!scope) {\n      throw new Error(\"Missing scope.\");\n    }\n\n    if (!disableChallengeResourceVerification) {\n      verifyChallengeResource(scope, request);\n    }\n\n    const accessToken = await getAccessToken([scope], {\n      ...getTokenOptions,\n      tenantId: parsedChallenge.tenantId,\n    });\n\n    if (!accessToken) {\n      return false;\n    }\n\n    request.headers.set(\"Authorization\", `Bearer ${accessToken.token}`);\n\n    challengeState = {\n      status: \"complete\",\n      scopes: [scope],\n    };\n\n    return true;\n  }\n\n  return {\n    authorizeRequest,\n    authorizeRequestOnChallenge,\n  };\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\n/**\n * The parsed components of a Key Vault entity identifier.\n */\nexport interface KeyVaultEntityIdentifier {\n  /**\n   * The vault URI.\n   */\n  vaultUrl: string;\n  /**\n   * The version of key/secret/certificate. May be undefined.\n   */\n  version?: string;\n  /**\n   * The name of key/secret/certificate.\n   */\n  name: string;\n}\n\n/**\n * Parses a Key Vault identifier into its components.\n *\n * @param collection - The collection of the Key Vault identifier.\n * @param identifier - The Key Vault identifier to be parsed.\n */\nexport function parseKeyVaultIdentifier(\n  collection: string,\n  identifier: string | undefined\n): KeyVaultEntityIdentifier {\n  if (typeof collection !== \"string\" || !(collection = collection.trim())) {\n    throw new Error(\"Invalid collection argument\");\n  }\n\n  if (typeof identifier !== \"string\" || !(identifier = identifier.trim())) {\n    throw new Error(\"Invalid identifier argument\");\n  }\n\n  let baseUri;\n  try {\n    baseUri = new URL(identifier);\n  } catch (e: any) {\n    throw new Error(`Invalid ${collection} identifier: ${identifier}. Not a valid URI`);\n  }\n\n  // Path is of the form '/collection/name[/version]'\n  const segments = (baseUri.pathname || \"\").split(\"/\");\n  if (segments.length !== 3 && segments.length !== 4) {\n    throw new Error(\n      `Invalid ${collection} identifier: ${identifier}. Bad number of segments: ${segments.length}`\n    );\n  }\n\n  if (collection !== segments[1]) {\n    throw new Error(\n      `Invalid ${collection} identifier: ${identifier}. segment [1] should be \"${collection}\", found \"${segments[1]}\"`\n    );\n  }\n\n  const vaultUrl = `${baseUri.protocol}//${baseUri.host}`;\n  const name = segments[2];\n  const version = segments.length === 4 ? segments[3] : undefined;\n  return {\n    vaultUrl,\n    name,\n    version,\n  };\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { createTracingClient } from \"@azure/core-tracing\";\nimport { SDK_VERSION } from \"./constants\";\n\nexport const tracingClient = createTracingClient({\n  namespace: \"Microsoft.KeyVault\",\n  packageName: \"@azure/keyvault-keys\",\n  packageVersion: SDK_VERSION,\n});\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { parseKeyVaultIdentifier } from \"../../keyvault-common/src\";\n\n/**\n * Represents the segments that compose a Key Vault Key Id.\n */\nexport interface KeyVaultKeyIdentifier {\n  /**\n   * The complete representation of the Key Vault Key Id. For example:\n   *\n   *   https://<keyvault-name>.vault.azure.net/keys/<key-name>/<unique-version-id>\n   *\n   */\n  sourceId: string;\n\n  /**\n   * The URL of the Azure Key Vault instance to which the Key belongs.\n   */\n  vaultUrl: string;\n\n  /**\n   * The version of Key Vault Key. Might be undefined.\n   */\n  version?: string;\n\n  /**\n   * The name of the Key Vault Key.\n   */\n  name: string;\n}\n\n/**\n * Parses the given Key Vault Key Id. An example is:\n *\n *   https://<keyvault-name>.vault.azure.net/keys/<key-name>/<unique-version-id>\n *\n * On parsing the above Id, this function returns:\n *```ts\n *   {\n *      sourceId: \"https://<keyvault-name>.vault.azure.net/keys/<key-name>/<unique-version-id>\",\n *      vaultUrl: \"https://<keyvault-name>.vault.azure.net\",\n *      version: \"<unique-version-id>\",\n *      name: \"<key-name>\"\n *   }\n *```\n * @param id - The Id of the Key Vault Key.\n */\nexport function parseKeyVaultKeyIdentifier(id: string): KeyVaultKeyIdentifier {\n  const urlParts = id.split(\"/\");\n  const collection = urlParts[3];\n\n  return {\n    sourceId: id,\n    ...parseKeyVaultIdentifier(collection, id),\n  };\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  DeletedKeyBundle,\n  DeletedKeyItem,\n  KeyRotationPolicy as GeneratedPolicy,\n  KeyAttributes,\n  KeyBundle,\n  KeyItem,\n  LifetimeActions,\n} from \"./generated/models\";\nimport { parseKeyVaultKeyIdentifier } from \"./identifier\";\nimport {\n  DeletedKey,\n  KeyProperties,\n  KeyRotationPolicy,\n  KeyRotationPolicyProperties,\n  KeyVaultKey,\n} from \"./keysModels\";\n\n/**\n * @internal\n * Shapes the exposed {@link KeyVaultKey} based on either a received key bundle or deleted key bundle.\n */\nexport function getKeyFromKeyBundle(\n  bundle: KeyBundle | DeletedKeyBundle\n): KeyVaultKey | DeletedKey {\n  const keyBundle = bundle as KeyBundle;\n  const deletedKeyBundle = bundle as DeletedKeyBundle;\n\n  const parsedId = parseKeyVaultKeyIdentifier(keyBundle.key!.kid!);\n\n  const attributes: KeyAttributes = keyBundle.attributes || {};\n  delete keyBundle.attributes;\n\n  const resultObject: KeyVaultKey | DeletedKey = {\n    key: keyBundle.key,\n    id: keyBundle.key ? keyBundle.key.kid : undefined,\n    name: parsedId.name,\n    keyOperations: keyBundle.key ? keyBundle.key.keyOps : undefined,\n    keyType: keyBundle.key ? keyBundle.key.kty : undefined,\n    properties: {\n      tags: keyBundle.tags,\n\n      enabled: attributes.enabled,\n      notBefore: attributes.notBefore,\n      expiresOn: attributes.expires,\n      createdOn: attributes.created,\n      updatedOn: attributes.updated,\n      recoverableDays: attributes.recoverableDays,\n      recoveryLevel: attributes.recoveryLevel,\n      exportable: attributes.exportable,\n      releasePolicy: keyBundle.releasePolicy,\n\n      vaultUrl: parsedId.vaultUrl,\n      version: parsedId.version,\n      name: parsedId.name,\n      managed: keyBundle.managed,\n\n      id: keyBundle.key ? keyBundle.key.kid : undefined,\n    },\n  };\n\n  if (deletedKeyBundle.recoveryId) {\n    (resultObject as any).properties.recoveryId = deletedKeyBundle.recoveryId;\n    (resultObject as any).properties.scheduledPurgeDate = deletedKeyBundle.scheduledPurgeDate;\n    (resultObject as any).properties.deletedOn = deletedKeyBundle.deletedDate;\n  }\n\n  return resultObject;\n}\n\n/**\n * @internal\n * Shapes the exposed {@link DeletedKey} based on a received KeyItem.\n */\nexport function getDeletedKeyFromDeletedKeyItem(keyItem: DeletedKeyItem): DeletedKey {\n  const commonProperties = getKeyPropertiesFromKeyItem(keyItem);\n\n  return {\n    key: {\n      kid: keyItem.kid,\n    },\n    id: keyItem.kid,\n    name: commonProperties.name,\n    properties: {\n      ...commonProperties,\n      recoveryId: keyItem.recoveryId,\n      scheduledPurgeDate: keyItem.scheduledPurgeDate,\n      deletedOn: keyItem.deletedDate,\n    },\n  };\n}\n\n/**\n * @internal\n * Shapes the exposed {@link KeyProperties} based on a received KeyItem.\n */\nexport function getKeyPropertiesFromKeyItem(keyItem: KeyItem): KeyProperties {\n  const parsedId = parseKeyVaultKeyIdentifier(keyItem.kid!);\n  const attributes = keyItem.attributes || {};\n\n  const resultObject: KeyProperties = {\n    createdOn: attributes.created,\n    enabled: attributes?.enabled,\n    expiresOn: attributes?.expires,\n    id: keyItem.kid,\n    managed: keyItem.managed,\n    name: parsedId.name,\n    notBefore: attributes?.notBefore,\n    recoverableDays: attributes?.recoverableDays,\n    recoveryLevel: attributes?.recoveryLevel,\n    tags: keyItem.tags,\n    updatedOn: attributes.updated,\n    vaultUrl: parsedId.vaultUrl,\n    version: parsedId.version,\n  };\n\n  return resultObject;\n}\n\n/**\n * @internal\n */\nexport const keyRotationTransformations = {\n  propertiesToGenerated: function (\n    parameters: KeyRotationPolicyProperties\n  ): Partial<GeneratedPolicy> {\n    const policy: GeneratedPolicy = {\n      attributes: {\n        expiryTime: parameters.expiresIn,\n      },\n      lifetimeActions: parameters.lifetimeActions?.map((action) => {\n        const generatedAction: LifetimeActions = {\n          action: { type: action.action },\n          trigger: {},\n        };\n\n        if (action.timeAfterCreate) {\n          generatedAction.trigger!.timeAfterCreate = action.timeAfterCreate;\n        }\n\n        if (action.timeBeforeExpiry) {\n          generatedAction.trigger!.timeBeforeExpiry = action.timeBeforeExpiry;\n        }\n\n        return generatedAction;\n      }),\n    };\n    return policy;\n  },\n  generatedToPublic(generated: GeneratedPolicy): KeyRotationPolicy {\n    const policy: KeyRotationPolicy = {\n      id: generated.id,\n      createdOn: generated.attributes?.created,\n      updatedOn: generated.attributes?.updated,\n      expiresIn: generated.attributes?.expiryTime,\n      lifetimeActions: generated.lifetimeActions?.map((action) => {\n        return {\n          action: action.action!.type!,\n          timeAfterCreate: action.trigger?.timeAfterCreate,\n          timeBeforeExpiry: action.trigger?.timeBeforeExpiry,\n        };\n      }),\n    };\n    return policy;\n  },\n};\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { OperationOptions } from \"@azure/core-client\";\nimport { delay } from \"@azure/core-util\";\nimport { Poller, PollOperation, PollOperationState } from \"@azure/core-lro\";\nimport { KeyVaultClient } from \"../generated/keyVaultClient\";\n\n/**\n * Common parameters to a Key Vault Key Poller.\n */\nexport interface KeyVaultKeyPollerOptions {\n  vaultUrl: string;\n  client: KeyVaultClient;\n  name: string;\n  operationOptions?: OperationOptions;\n  intervalInMs?: number;\n  resumeFrom?: string;\n}\n\n/**\n * An interface representing the state of a Key Vault Key Poller's operation.\n */\nexport interface KeyVaultKeyPollOperationState<TResult> extends PollOperationState<TResult> {\n  /**\n   * The name of the key.\n   */\n  name: string;\n}\n\n/**\n * Common properties and methods of the Key Vault Key Pollers.\n */\nexport abstract class KeyVaultKeyPoller<\n  TState extends KeyVaultKeyPollOperationState<TResult>,\n  TResult\n> extends Poller<TState, TResult> {\n  /**\n   * Defines how much time the poller is going to wait before making a new request to the service.\n   */\n  public intervalInMs: number = 2000;\n\n  /**\n   * The method used by the poller to wait before attempting to update its operation.\n   */\n  async delay(): Promise<void> {\n    return delay(this.intervalInMs);\n  }\n}\n\n/**\n * Optional parameters to the KeyVaultKeyPollOperation\n */\nexport interface KeyVaultKeyPollOperationOptions {\n  cancelMessage?: string;\n}\n\n/**\n * Common properties and methods of the Key Vault Key Poller operations.\n */\nexport class KeyVaultKeyPollOperation<TState, TResult> implements PollOperation<TState, TResult> {\n  private cancelMessage: string = \"\";\n\n  constructor(public state: TState, options: KeyVaultKeyPollOperationOptions = {}) {\n    if (options.cancelMessage) {\n      this.cancelMessage = options.cancelMessage;\n    }\n  }\n\n  /**\n   * Meant to reach to the service and update the Poller operation.\n   */\n  public async update(): Promise<PollOperation<TState, TResult>> {\n    throw new Error(\"Operation not supported.\");\n  }\n\n  /**\n   * Meant to reach to the service and cancel the Poller operation.\n   */\n  public async cancel(): Promise<PollOperation<TState, TResult>> {\n    throw new Error(this.cancelMessage);\n  }\n\n  /**\n   * Serializes the Poller operation.\n   */\n  public toString(): string {\n    return JSON.stringify({\n      state: this.state,\n    });\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { AbortSignalLike } from \"@azure/abort-controller\";\nimport { OperationOptions } from \"@azure/core-client\";\nimport { KeyVaultClient } from \"../../generated/keyVaultClient\";\nimport { DeleteKeyOptions, DeletedKey, GetDeletedKeyOptions } from \"../../keysModels\";\nimport { tracingClient } from \"../../tracing\";\nimport { getKeyFromKeyBundle } from \"../../transformations\";\nimport { KeyVaultKeyPollOperation, KeyVaultKeyPollOperationState } from \"../keyVaultKeyPoller\";\n\n/**\n * An interface representing the state of a delete key's poll operation\n */\nexport interface DeleteKeyPollOperationState extends KeyVaultKeyPollOperationState<DeletedKey> {}\n\nexport class DeleteKeyPollOperation extends KeyVaultKeyPollOperation<\n  DeleteKeyPollOperationState,\n  DeletedKey\n> {\n  constructor(\n    public state: DeleteKeyPollOperationState,\n    private vaultUrl: string,\n    private client: KeyVaultClient,\n    private operationOptions: OperationOptions = {}\n  ) {\n    super(state, { cancelMessage: \"Canceling the deletion of a key is not supported.\" });\n  }\n\n  /**\n   * Sends a delete request for the given Key Vault Key's name to the Key Vault service.\n   * Since the Key Vault Key won't be immediately deleted, we have {@link beginDeleteKey}.\n   */\n  private deleteKey(name: string, options: DeleteKeyOptions = {}): Promise<DeletedKey> {\n    return tracingClient.withSpan(\"DeleteKeyPoller.deleteKey\", options, async (updatedOptions) => {\n      const response = await this.client.deleteKey(this.vaultUrl, name, updatedOptions);\n      return getKeyFromKeyBundle(response);\n    });\n  }\n\n  /**\n   * The getDeletedKey method returns the specified deleted key along with its properties.\n   * This operation requires the keys/get permission.\n   */\n  private getDeletedKey(name: string, options: GetDeletedKeyOptions = {}): Promise<DeletedKey> {\n    return tracingClient.withSpan(\n      \"DeleteKeyPoller.getDeletedKey\",\n      options,\n      async (updatedOptions) => {\n        const response = await this.client.getDeletedKey(this.vaultUrl, name, updatedOptions);\n        return getKeyFromKeyBundle(response);\n      }\n    );\n  }\n\n  /**\n   * Reaches to the service and updates the delete key's poll operation.\n   */\n  public async update(\n    options: {\n      abortSignal?: AbortSignalLike;\n      fireProgress?: (state: DeleteKeyPollOperationState) => void;\n    } = {}\n  ): Promise<DeleteKeyPollOperation> {\n    const state = this.state;\n    const { name } = state;\n\n    if (options.abortSignal) {\n      this.operationOptions.abortSignal = options.abortSignal;\n    }\n\n    if (!state.isStarted) {\n      const deletedKey = await this.deleteKey(name, this.operationOptions);\n      state.isStarted = true;\n      state.result = deletedKey;\n      if (!deletedKey.properties.recoveryId) {\n        state.isCompleted = true;\n      }\n    }\n\n    if (!state.isCompleted) {\n      try {\n        state.result = await this.getDeletedKey(name, this.operationOptions);\n        state.isCompleted = true;\n      } catch (error: any) {\n        if (error.statusCode === 403) {\n          // At this point, the resource exists but the user doesn't have access to it.\n          state.isCompleted = true;\n        } else if (error.statusCode !== 404) {\n          state.error = error;\n          state.isCompleted = true;\n          throw error;\n        }\n      }\n    }\n\n    return this;\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { DeleteKeyPollOperation, DeleteKeyPollOperationState } from \"./operation\";\nimport { DeletedKey } from \"../../keysModels\";\nimport { KeyVaultKeyPoller, KeyVaultKeyPollerOptions } from \"../keyVaultKeyPoller\";\n\n/**\n * Class that creates a poller that waits until a key finishes being deleted.\n */\nexport class DeleteKeyPoller extends KeyVaultKeyPoller<DeleteKeyPollOperationState, DeletedKey> {\n  constructor(options: KeyVaultKeyPollerOptions) {\n    const { vaultUrl, client, name, operationOptions, intervalInMs = 2000, resumeFrom } = options;\n\n    let state: DeleteKeyPollOperationState | undefined;\n\n    if (resumeFrom) {\n      state = JSON.parse(resumeFrom).state;\n    }\n\n    const operation = new DeleteKeyPollOperation(\n      {\n        ...state,\n        name,\n      },\n      vaultUrl,\n      client,\n      operationOptions\n    );\n\n    super(operation);\n\n    this.intervalInMs = intervalInMs;\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { AbortSignalLike } from \"@azure/abort-controller\";\nimport { OperationOptions } from \"@azure/core-client\";\nimport { KeyVaultClient } from \"../../generated/keyVaultClient\";\nimport { GetKeyOptions, KeyVaultKey, RecoverDeletedKeyOptions } from \"../../keysModels\";\nimport { tracingClient } from \"../../tracing\";\nimport { getKeyFromKeyBundle } from \"../../transformations\";\nimport { KeyVaultKeyPollOperation, KeyVaultKeyPollOperationState } from \"../keyVaultKeyPoller\";\n\n/**\n * An interface representing the state of a delete key's poll operation\n */\nexport interface RecoverDeletedKeyPollOperationState\n  extends KeyVaultKeyPollOperationState<KeyVaultKey> {}\n\nexport class RecoverDeletedKeyPollOperation extends KeyVaultKeyPollOperation<\n  RecoverDeletedKeyPollOperationState,\n  KeyVaultKey\n> {\n  constructor(\n    public state: RecoverDeletedKeyPollOperationState,\n    private vaultUrl: string,\n    private client: KeyVaultClient,\n    private operationOptions: OperationOptions = {}\n  ) {\n    super(state, { cancelMessage: \"Canceling the recovery of a deleted key is not supported.\" });\n  }\n\n  /**\n   * The getKey method gets a specified key and is applicable to any key stored in Azure Key Vault.\n   * This operation requires the keys/get permission.\n   */\n  private getKey(name: string, options: GetKeyOptions = {}): Promise<KeyVaultKey> {\n    return tracingClient.withSpan(\n      \"RecoverDeleteKeyPoller.getKey\",\n      options,\n      async (updatedOptions) => {\n        const response = await this.client.getKey(\n          this.vaultUrl,\n          name,\n          updatedOptions?.version || \"\",\n          updatedOptions\n        );\n        return getKeyFromKeyBundle(response);\n      }\n    );\n  }\n\n  /**\n   * Sends a request to recover a deleted Key Vault Key based on the given name.\n   * Since the Key Vault Key won't be immediately recover the deleted key, we have {@link beginRecoverDeletedKey}.\n   */\n  private async recoverDeletedKey(\n    name: string,\n    options: RecoverDeletedKeyOptions = {}\n  ): Promise<KeyVaultKey> {\n    return tracingClient.withSpan(\n      \"RecoverDeletedKeyPoller.recoverDeleteKey\",\n      options,\n      async (updatedOptions) => {\n        const response = await this.client.recoverDeletedKey(this.vaultUrl, name, updatedOptions);\n        return getKeyFromKeyBundle(response);\n      }\n    );\n  }\n\n  /**\n   * Reaches to the service and updates the delete key's poll operation.\n   */\n  public async update(\n    options: {\n      abortSignal?: AbortSignalLike;\n      fireProgress?: (state: RecoverDeletedKeyPollOperationState) => void;\n    } = {}\n  ): Promise<RecoverDeletedKeyPollOperation> {\n    const state = this.state;\n    const { name } = state;\n\n    const operationOptions = this.operationOptions;\n    if (options.abortSignal) {\n      operationOptions.abortSignal = options.abortSignal;\n    }\n\n    if (!state.isStarted) {\n      try {\n        state.result = await this.getKey(name, operationOptions);\n        state.isCompleted = true;\n      } catch {\n        // Nothing to do here.\n      }\n      if (!state.isCompleted) {\n        state.result = await this.recoverDeletedKey(name, operationOptions);\n        state.isStarted = true;\n      }\n    }\n\n    if (!state.isCompleted) {\n      try {\n        state.result = await this.getKey(name, operationOptions);\n        state.isCompleted = true;\n      } catch (error: any) {\n        if (error.statusCode === 403) {\n          // At this point, the resource exists but the user doesn't have access to it.\n          state.isCompleted = true;\n        } else if (error.statusCode !== 404) {\n          state.error = error;\n          state.isCompleted = true;\n          throw error;\n        }\n      }\n    }\n\n    return this;\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { RecoverDeletedKeyPollOperation, RecoverDeletedKeyPollOperationState } from \"./operation\";\nimport { KeyVaultKey } from \"../../keysModels\";\nimport { KeyVaultKeyPoller, KeyVaultKeyPollerOptions } from \"../keyVaultKeyPoller\";\n\n/**\n * Class that deletes a poller that waits until a key finishes being deleted\n */\nexport class RecoverDeletedKeyPoller extends KeyVaultKeyPoller<\n  RecoverDeletedKeyPollOperationState,\n  KeyVaultKey\n> {\n  constructor(options: KeyVaultKeyPollerOptions) {\n    const { vaultUrl, client, name, operationOptions, intervalInMs = 2000, resumeFrom } = options;\n\n    let state: RecoverDeletedKeyPollOperationState | undefined;\n\n    if (resumeFrom) {\n      state = JSON.parse(resumeFrom).state;\n    }\n\n    const operation = new RecoverDeletedKeyPollOperation(\n      {\n        ...state,\n        name,\n      },\n      vaultUrl,\n      client,\n      operationOptions\n    );\n\n    super(operation);\n\n    this.intervalInMs = intervalInMs;\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport * as coreClient from \"@azure/core-client\";\nimport { ExtendedCommonClientOptions } from \"@azure/core-http-compat\";\n\nimport {\n  DeletionRecoveryLevel,\n  JsonWebKeyOperation as KeyOperation,\n  JsonWebKeyType as KeyType,\n  KnownJsonWebKeyType as KnownKeyTypes,\n} from \"./generated/models\";\n\nimport { KeyCurveName } from \"./cryptographyClientModels\";\n\nexport { KeyType, KnownKeyTypes, KeyOperation };\n\n/**\n * The latest supported Key Vault service API version\n */\nexport const LATEST_API_VERSION = \"7.4\";\n\n/**\n * The optional parameters accepted by the KeyVault's KeyClient\n */\nexport interface KeyClientOptions extends ExtendedCommonClientOptions {\n  /**\n   * The version of the KeyVault's service API to make calls against.\n   */\n  serviceVersion?: string;\n\n  /**\n   * Whether to disable verification that the authentication challenge resource matches the Key Vault or Managed HSM domain.\n   * Defaults to false.\n   */\n  disableChallengeResourceVerification?: boolean;\n}\n\n/**\n * The optional parameters accepted by the KeyVault's CryptographyClient\n */\nexport interface CryptographyClientOptions extends KeyClientOptions {}\n\n/**\n * As of http://tools.ietf.org/html/draft-ietf-jose-json-web-key-18\n */\nexport interface JsonWebKey {\n  /**\n   * Key identifier.\n   */\n  kid?: string;\n  /**\n   * JsonWebKey Key Type (kty), as defined in\n   * https://tools.ietf.org/html/draft-ietf-jose-json-web-algorithms-40. Possible values include:\n   * 'EC', 'EC-HSM', 'RSA', 'RSA-HSM', 'oct', \"oct-HSM\"\n   */\n  kty?: KeyType;\n  /**\n   * Json web key operations. For more\n   * information on possible key operations, see KeyOperation.\n   */\n  keyOps?: KeyOperation[];\n  /**\n   * RSA modulus.\n   */\n  n?: Uint8Array;\n  /**\n   * RSA public exponent.\n   */\n  e?: Uint8Array;\n  /**\n   * RSA private exponent, or the D component of an EC private key.\n   */\n  d?: Uint8Array;\n  /**\n   * RSA private key parameter.\n   */\n  dp?: Uint8Array;\n  /**\n   * RSA private key parameter.\n   */\n  dq?: Uint8Array;\n  /**\n   * RSA private key parameter.\n   */\n  qi?: Uint8Array;\n  /**\n   * RSA secret prime.\n   */\n  p?: Uint8Array;\n  /**\n   * RSA secret prime, with `p < q`.\n   */\n  q?: Uint8Array;\n  /**\n   * Symmetric key.\n   */\n  k?: Uint8Array;\n  /**\n   * HSM Token, used with 'Bring Your Own Key'.\n   */\n  t?: Uint8Array;\n  /**\n   * Elliptic curve name. For valid values, see KeyCurveName. Possible values include:\n   * 'P-256', 'P-384', 'P-521', 'P-256K'\n   */\n  crv?: KeyCurveName;\n  /**\n   * X component of an EC public key.\n   */\n  x?: Uint8Array;\n  /**\n   * Y component of an EC public key.\n   */\n  y?: Uint8Array;\n}\n\n/**\n * An interface representing a Key Vault Key, with its name, value and {@link KeyProperties}.\n */\nexport interface KeyVaultKey {\n  /**\n   * The key value.\n   */\n  key?: JsonWebKey;\n  /**\n   * The name of the key.\n   */\n  name: string;\n  /**\n   * Key identifier.\n   */\n  id?: string;\n  /**\n   * JsonWebKey Key Type (kty), as defined in\n   * https://tools.ietf.org/html/draft-ietf-jose-json-web-algorithms-40. Possible values include:\n   * 'EC', 'EC-HSM', 'RSA', 'RSA-HSM', 'oct', \"oct-HSM\"\n   */\n  keyType?: KeyType;\n  /**\n   * Operations allowed on this key\n   */\n  keyOperations?: KeyOperation[];\n  /**\n   * The properties of the key.\n   */\n  properties: KeyProperties;\n}\n\n/**\n * An interface representing the Properties of {@link KeyVaultKey}\n */\nexport interface KeyProperties {\n  /**\n   * Key identifier.\n   */\n  id?: string;\n  /**\n   * The name of the key.\n   */\n  name: string;\n  /**\n   * The vault URI.\n   */\n  vaultUrl: string;\n  /**\n   * The version of the key. May be undefined.\n   */\n  version?: string;\n  /**\n   * Determines whether the object is enabled.\n   */\n  enabled?: boolean;\n  /**\n   * Not before date in UTC.\n   */\n  notBefore?: Date;\n  /**\n   * Expiry date in UTC.\n   */\n  expiresOn?: Date;\n  /**\n   * Application specific metadata in the form of key-value pairs.\n   */\n  tags?: { [propertyName: string]: string };\n  /**\n   * Creation time in UTC.\n   * **NOTE: This property will not be serialized. It can only be populated by\n   * the server.**\n   */\n  readonly createdOn?: Date;\n  /**\n   * Last updated time in UTC.\n   * **NOTE: This property will not be serialized. It can only be populated by\n   * the server.**\n   */\n  readonly updatedOn?: Date;\n  /**\n   * Reflects the deletion recovery level currently in effect for keys in the current vault.\n   * If it contains 'Purgeable' the key can be permanently deleted by a privileged\n   * user; otherwise, only the system can purge the key, at the end of the\n   * retention interval. Possible values include: 'Purgeable',\n   * 'Recoverable+Purgeable', 'Recoverable',\n   * 'Recoverable+ProtectedSubscription'\n   * **NOTE: This property will not be serialized. It can only be populated by\n   * the server.**\n   */\n  readonly recoveryLevel?: DeletionRecoveryLevel;\n  /**\n   * The retention dates of the softDelete data.\n   * The value should be `>=7` and `<=90` when softDelete enabled.\n   * **NOTE: This property will not be serialized. It can only be populated by the server.**\n   */\n  recoverableDays?: number;\n\n  /**\n   * True if the secret's lifetime is managed by\n   * key vault. If this is a secret backing a certificate, then managed will be\n   * true.\n   * **NOTE: This property will not be serialized. It can only be populated by\n   * the server.**\n   */\n  readonly managed?: boolean;\n\n  /**\n   * Indicates whether the private key can be exported.\n   */\n  exportable?: boolean;\n\n  /**\n   * A {@link KeyReleasePolicy} object specifying the rules under which the key can be exported.\n   */\n  releasePolicy?: KeyReleasePolicy;\n}\n\n/**\n * An interface representing a deleted Key Vault Key.\n */\nexport interface DeletedKey {\n  /**\n   * The key value.\n   */\n  key?: JsonWebKey;\n  /**\n   * The name of the key.\n   */\n  name: string;\n  /**\n   * Key identifier.\n   */\n  id?: string;\n  /**\n   * JsonWebKey Key Type (kty), as defined in\n   * https://tools.ietf.org/html/draft-ietf-jose-json-web-algorithms-40. Possible values include:\n   * 'EC', 'EC-HSM', 'RSA', 'RSA-HSM', 'oct', \"oct-HSM\"\n   */\n  keyType?: KeyType;\n  /**\n   * Operations allowed on this key\n   */\n  keyOperations?: KeyOperation[];\n  /**\n   * The properties of the key.\n   */\n  properties: KeyProperties & {\n    /**\n     * The url of the recovery object, used to\n     * identify and recover the deleted key.\n     */\n    readonly recoveryId?: string;\n    /**\n     * The time when the key is scheduled to be purged, in UTC\n     * **NOTE: This property will not be serialized. It can only be populated by\n     * the server.**\n     */\n    readonly scheduledPurgeDate?: Date;\n    /**\n     * The time when the key was deleted, in UTC\n     * **NOTE: This property will not be serialized. It can only be populated by\n     * the server.**\n     */\n    deletedOn?: Date;\n  };\n}\n\n/**\n * The policy rules under which a key can be exported.\n */\nexport interface KeyReleasePolicy {\n  /**\n   * Content type and version of key release policy.\n   *\n   * Defaults to \"application/json; charset=utf-8\" if omitted.\n   */\n  contentType?: string;\n\n  /**\n   * The policy rules under which the key can be released. Encoded based on the {@link KeyReleasePolicy.contentType}.\n   *\n   * For more information regarding the release policy grammar for Azure Key Vault, please refer to:\n   * - https://aka.ms/policygrammarkeys for Azure Key Vault release policy grammar.\n   * - https://aka.ms/policygrammarmhsm for Azure Managed HSM release policy grammar.\n   */\n  encodedPolicy?: Uint8Array;\n\n  /** Marks a release policy as immutable. An immutable release policy cannot be changed or updated after being marked immutable. */\n  immutable?: boolean;\n}\n\n/**\n * An interface representing the optional parameters that can be\n * passed to {@link createKey}\n */\nexport interface CreateKeyOptions extends coreClient.OperationOptions {\n  /**\n   * Application specific metadata in the form of key-value pairs.\n   */\n  tags?: { [propertyName: string]: string };\n  /**\n   * Json web key operations. For more\n   * information on possible key operations, see KeyOperation.\n   */\n  keyOps?: KeyOperation[];\n  /**\n   * Determines whether the object is enabled.\n   */\n  enabled?: boolean;\n  /**\n   * Not before date in UTC.\n   */\n  notBefore?: Date;\n  /**\n   * Expiry date in UTC.\n   */\n  readonly expiresOn?: Date;\n  /**\n   * The key size in bits. For example: 2048, 3072, or 4096 for RSA.\n   */\n  keySize?: number;\n  /**\n   * Elliptic curve name. For valid values, see KeyCurveName.\n   * Possible values include: 'P-256', 'P-384', 'P-521', 'P-256K'\n   */\n  curve?: KeyCurveName;\n  /**\n   * Whether to import as a hardware key (HSM) or software key.\n   */\n  hsm?: boolean;\n\n  /**\n   * Indicates whether the private key can be exported.\n   */\n  exportable?: boolean;\n\n  /**\n   * A {@link KeyReleasePolicy} object specifying the rules under which the key can be exported.\n   */\n  releasePolicy?: KeyReleasePolicy;\n}\n\n/**\n * An interface representing the optional parameters that can be\n * passed to {@link beginDeleteKey} and {@link beginRecoverDeletedKey}\n */\nexport interface KeyPollerOptions extends coreClient.OperationOptions {\n  /**\n   * Time between each polling\n   */\n  intervalInMs?: number;\n  /**\n   * A serialized poller, used to resume an existing operation\n   */\n  resumeFrom?: string;\n}\n\n/**\n * An interface representing the optional parameters that can be\n * passed to {@link beginDeleteKey}\n */\nexport interface BeginDeleteKeyOptions extends KeyPollerOptions {}\n\n/**\n * An interface representing the optional parameters that can be\n * passed to {@link beginRecoverDeletedKey}\n */\nexport interface BeginRecoverDeletedKeyOptions extends KeyPollerOptions {}\n\n/**\n * An interface representing the optional parameters that can be\n * passed to {@link createEcKey}\n */\nexport interface CreateEcKeyOptions extends CreateKeyOptions {}\n\n/**\n * An interface representing the optional parameters that can be\n * passed to {@link createRsaKey}\n */\nexport interface CreateRsaKeyOptions extends CreateKeyOptions {\n  /** The public exponent for a RSA key. */\n  publicExponent?: number;\n}\n\n/**\n * An interface representing the optional parameters that can be\n * passed to {@link createOctKey}\n */\nexport interface CreateOctKeyOptions extends CreateKeyOptions {}\n\n/**\n * An interface representing the optional parameters that can be\n * passed to {@link importKey}\n */\nexport interface ImportKeyOptions extends coreClient.OperationOptions {\n  /**\n   * Application specific metadata in the form of key-value pairs.\n   */\n  tags?: { [propertyName: string]: string };\n  /**\n   * Whether to import as a hardware key (HSM) or software key.\n   */\n  hardwareProtected?: boolean;\n  /**\n   * Determines whether the object is enabled.\n   */\n  enabled?: boolean;\n  /**\n   * Not before date in UTC.\n   */\n  notBefore?: Date;\n  /**\n   * Expiry date in UTC.\n   */\n  expiresOn?: Date;\n\n  /**\n   * Indicates whether the private key can be exported.\n   */\n  exportable?: boolean;\n\n  /**\n   * A {@link KeyReleasePolicy} object specifying the rules under which the key can be exported.\n   */\n  releasePolicy?: KeyReleasePolicy;\n}\n\n/**\n * Options for {@link updateKeyProperties}.\n */\nexport interface UpdateKeyPropertiesOptions extends coreClient.OperationOptions {\n  /**\n   * Json web key operations. For more\n   * information on possible key operations, see KeyOperation.\n   */\n  keyOps?: KeyOperation[];\n  /**\n   * Determines whether the object is enabled.\n   */\n  enabled?: boolean;\n  /**\n   * Not before date in UTC.\n   */\n  notBefore?: Date;\n  /**\n   * Expiry date in UTC.\n   */\n  expiresOn?: Date;\n  /**\n   * Application specific metadata in the form of key-value pairs.\n   */\n  tags?: { [propertyName: string]: string };\n\n  /**\n   * A {@link KeyReleasePolicy} object specifying the rules under which the key can be exported.\n   * Only valid if the key is marked exportable, which cannot be changed after key creation.\n   */\n  releasePolicy?: KeyReleasePolicy;\n}\n\n/**\n * Options for {@link getKey}.\n */\nexport interface GetKeyOptions extends coreClient.OperationOptions {\n  /**\n   * The version of the secret to retrieve. If not\n   * specified the latest version of the secret will be retrieved.\n   */\n  version?: string;\n}\n\n/**\n * An interface representing optional parameters for KeyClient paged operations passed to {@link listKeys}.\n */\nexport interface ListKeysOptions extends coreClient.OperationOptions {}\n\n/**\n * An interface representing optional parameters for KeyClient paged operations passed to {@link listPropertiesOfKeys}.\n */\nexport interface ListPropertiesOfKeysOptions extends coreClient.OperationOptions {}\n\n/**\n * An interface representing optional parameters for KeyClient paged operations passed to {@link listPropertiesOfKeyVersions}.\n */\nexport interface ListPropertiesOfKeyVersionsOptions extends coreClient.OperationOptions {}\n\n/**\n * An interface representing optional parameters for KeyClient paged operations passed to {@link listDeletedKeys}.\n */\nexport interface ListDeletedKeysOptions extends coreClient.OperationOptions {}\n\n/**\n * Options for {@link getDeletedKey}.\n */\nexport interface GetDeletedKeyOptions extends coreClient.OperationOptions {}\n\n/**\n * Options for {@link purgeDeletedKey}.\n */\nexport interface PurgeDeletedKeyOptions extends coreClient.OperationOptions {}\n\n/**\n * @internal\n * Options for {@link recoverDeletedKey}.\n */\nexport interface RecoverDeletedKeyOptions extends coreClient.OperationOptions {}\n\n/**\n * @internal\n * Options for {@link deleteKey}.\n */\nexport interface DeleteKeyOptions extends coreClient.OperationOptions {}\n\n/**\n * Options for {@link backupKey}.\n */\nexport interface BackupKeyOptions extends coreClient.OperationOptions {}\n\n/**\n * Options for {@link restoreKeyBackup}.\n */\nexport interface RestoreKeyBackupOptions extends coreClient.OperationOptions {}\n\n/**\n * An interface representing the options of the cryptography API methods, go to the {@link CryptographyClient} for more information.\n */\nexport interface CryptographyOptions extends coreClient.OperationOptions {}\n\n/**\n * Options for {@link KeyClient.getRandomBytes}\n */\nexport interface GetRandomBytesOptions extends coreClient.OperationOptions {}\n\n/**\n * Options for {@link KeyClient.releaseKey}\n */\nexport interface ReleaseKeyOptions extends coreClient.OperationOptions {\n  /** A client provided nonce for freshness. */\n  nonce?: string;\n\n  /** The {@link KeyExportEncryptionAlgorithm} to for protecting the exported key material. */\n  algorithm?: KeyExportEncryptionAlgorithm;\n\n  /**\n   * The version of the key to release. Defaults to the latest version of the key if omitted.\n   */\n  version?: string;\n}\n\n/**\n * Result of the {@link KeyClient.releaseKey} operation.\n */\nexport interface ReleaseKeyResult {\n  /** A signed token containing the released key. */\n  value: string;\n}\n\n/** Known values of {@link KeyOperation} that the service accepts. */\nexport enum KnownKeyOperations {\n  /** Key operation - encrypt */\n  Encrypt = \"encrypt\",\n  /** Key operation - decrypt */\n  Decrypt = \"decrypt\",\n  /** Key operation - sign */\n  Sign = \"sign\",\n  /** Key operation - verify */\n  Verify = \"verify\",\n  /** Key operation - wrapKey */\n  WrapKey = \"wrapKey\",\n  /** Key operation - unwrapKey */\n  UnwrapKey = \"unwrapKey\",\n  /** Key operation - import */\n  Import = \"import\",\n}\n\n/** Known values of {@link KeyExportEncryptionAlgorithm} that the service accepts. */\nexport enum KnownKeyExportEncryptionAlgorithm {\n  /** CKM_RSA_AES_KEY_WRAP Key Export Encryption Algorithm */\n  CkmRsaAesKeyWrap = \"CKM_RSA_AES_KEY_WRAP\",\n  /** RSA_AES_KEY_WRAP_256 Key Export Encryption Algorithm */\n  RsaAesKeyWrap256 = \"RSA_AES_KEY_WRAP_256\",\n  /** RSA_AES_KEY_WRAP_384 Key Export Encryption Algorithm */\n  RsaAesKeyWrap384 = \"RSA_AES_KEY_WRAP_384\",\n}\n\n/* eslint-disable tsdoc/syntax */\n/**\n * Defines values for KeyEncryptionAlgorithm.\n * {@link KnownKeyExportEncryptionAlgorithm} can be used interchangeably with KeyEncryptionAlgorithm,\n *  this enum contains the known values that the service supports.\n * ### Known values supported by the service\n * **CKM_RSA_AES_KEY_WRAP** \\\n * **RSA_AES_KEY_WRAP_256** \\\n * **RSA_AES_KEY_WRAP_384**\n */\nexport type KeyExportEncryptionAlgorithm = string;\n/* eslint-enable tsdoc/syntax */\n\n/**\n * Options for {@link KeyClient.getCryptographyClient}.\n */\nexport interface GetCryptographyClientOptions {\n  /**\n   * The version of the key to use for cryptographic operations.\n   *\n   * When undefined, the latest version of the key will be used.\n   */\n  keyVersion?: string;\n}\n\n/**\n * Options for {@link KeyClient.rotateKey}\n */\nexport interface RotateKeyOptions extends coreClient.OperationOptions {}\n\n/**\n * The properties of a key rotation policy that the client can set for a given key.\n *\n * You may also reset the key rotation policy to its default values by setting lifetimeActions to an empty array.\n */\nexport interface KeyRotationPolicyProperties {\n  /**\n   * Optional key expiration period used to define the duration after which a newly rotated key will expire, defined as an ISO 8601 duration.\n   */\n  expiresIn?: string;\n\n  /**\n   * Actions that will be performed by Key Vault over the lifetime of a key.\n   *\n   * You may also pass an empty array to restore to its default values.\n   */\n  lifetimeActions?: KeyRotationLifetimeAction[];\n}\n\n/**\n * The complete key rotation policy that belongs to a key.\n */\nexport interface KeyRotationPolicy extends KeyRotationPolicyProperties {\n  /**\n   * The identifier of the Key Rotation Policy.\n   * May be undefined if a policy has not been explicitly set.\n   */\n  readonly id?: string;\n\n  /**\n   * The created time in UTC.\n   * May be undefined if a policy has not been explicitly set.\n   */\n  readonly createdOn?: Date;\n\n  /**\n   * The last updated time in UTC.\n   * May be undefined if a policy has not been explicitly set.\n   */\n  readonly updatedOn?: Date;\n}\n\n/**\n * An action and its corresponding trigger that will be performed by Key Vault over the lifetime of a key.\n */\nexport interface KeyRotationLifetimeAction {\n  /**\n   * Time after creation to attempt the specified action, defined as an ISO 8601 duration.\n   */\n  timeAfterCreate?: string;\n\n  /**\n   * Time before expiry to attempt the specified action, defined as an ISO 8601 duration.\n   */\n  timeBeforeExpiry?: string;\n\n  /**\n   * The action that will be executed.\n   */\n  action: KeyRotationPolicyAction;\n}\n\n/**\n * The action that will be executed.\n */\nexport type KeyRotationPolicyAction = \"Rotate\" | \"Notify\";\n\n/**\n * Options for {@link KeyClient.updateKeyRotationPolicy}\n */\nexport interface UpdateKeyRotationPolicyOptions extends coreClient.OperationOptions {}\n\n/**\n * Options for {@link KeyClient.getRotationPolicy}\n */\nexport interface GetKeyRotationPolicyOptions extends coreClient.OperationOptions {}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  Verify,\n  createHash as cryptoCreateHash,\n  createVerify as cryptoCreateVerify,\n  randomBytes as cryptoRandomBytes,\n} from \"crypto\";\n\n/**\n * @internal\n * Mapping between signature algorithms and their corresponding hash algorithms. Externally used for testing.\n **/\nconst algorithmToHashAlgorithm: { [s: string]: string } = {\n  ES256: \"SHA256\",\n  ES256K: \"SHA256\",\n  PS256: \"SHA256\",\n  RS256: \"SHA256\",\n  ES384: \"SHA384\",\n  PS384: \"SHA384\",\n  RS384: \"SHA384\",\n  ES512: \"SHA512\",\n  PS512: \"SHA512\",\n  RS512: \"SHA512\",\n};\n\n/**\n * @internal\n * Use the platform-local hashing functionality\n */\nexport async function createHash(algorithm: string, data: Uint8Array): Promise<Buffer> {\n  const hashAlgorithm = algorithmToHashAlgorithm[algorithm];\n  if (!hashAlgorithm) {\n    throw new Error(\n      `Invalid algorithm ${algorithm} passed to createHash. Supported algorithms: ${Object.keys(\n        algorithmToHashAlgorithm\n      ).join(\", \")}`\n    );\n  }\n  const hash = cryptoCreateHash(hashAlgorithm);\n  hash.update(Buffer.from(data));\n  const digest = hash.digest();\n  return digest;\n}\n\n/**\n * @internal\n * Use the platform-local verify functionality\n */\nexport function createVerify(algorithm: string, data: Uint8Array): Verify {\n  const verifyAlgorithm = algorithmToHashAlgorithm[algorithm];\n  if (!verifyAlgorithm) {\n    throw new Error(\n      `Invalid algorithm ${algorithm} passed to createHash. Supported algorithms: ${Object.keys(\n        algorithmToHashAlgorithm\n      ).join(\", \")}`\n    );\n  }\n  const verifier = cryptoCreateVerify(verifyAlgorithm);\n  verifier.update(Buffer.from(data));\n  verifier.end();\n  return verifier;\n}\n\n/**\n * @internal\n * Use the platform-local randomBytes functionality\n */\nexport function randomBytes(length: number): Uint8Array {\n  return cryptoRandomBytes(length);\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { TokenCredential } from \"@azure/core-auth\";\nimport { bearerTokenAuthenticationPolicy } from \"@azure/core-rest-pipeline\";\n\nimport {\n  DecryptOptions,\n  DecryptParameters,\n  DecryptResult,\n  EncryptOptions,\n  EncryptParameters,\n  EncryptResult,\n  KeyWrapAlgorithm,\n  SignOptions,\n  SignResult,\n  UnwrapKeyOptions,\n  VerifyOptions,\n  VerifyResult,\n  WrapKeyOptions,\n  WrapResult,\n} from \"../cryptographyClientModels\";\nimport { SDK_VERSION } from \"../constants\";\nimport { UnwrapResult } from \"../cryptographyClientModels\";\nimport { KeyVaultClient } from \"../generated\";\nimport { parseKeyVaultKeyIdentifier } from \"../identifier\";\nimport {\n  CryptographyClientOptions,\n  GetKeyOptions,\n  KeyVaultKey,\n  LATEST_API_VERSION,\n} from \"../keysModels\";\nimport { getKeyFromKeyBundle } from \"../transformations\";\nimport { createHash } from \"./crypto\";\nimport { CryptographyProvider, CryptographyProviderOperation } from \"./models\";\nimport { logger } from \"../log\";\nimport { createKeyVaultChallengeCallbacks } from \"../../../keyvault-common/src\";\nimport { tracingClient } from \"../tracing\";\n\n/**\n * The remote cryptography provider is used to run crypto operations against KeyVault.\n * @internal\n */\nexport class RemoteCryptographyProvider implements CryptographyProvider {\n  constructor(\n    key: string | KeyVaultKey,\n    credential: TokenCredential,\n    pipelineOptions: CryptographyClientOptions = {}\n  ) {\n    this.client = getOrInitializeClient(credential, pipelineOptions);\n\n    this.key = key;\n\n    let keyId: string;\n    if (typeof key === \"string\") {\n      keyId = key;\n    } else {\n      keyId = key.id!;\n    }\n\n    try {\n      const parsed = parseKeyVaultKeyIdentifier(keyId);\n      if (parsed.name === \"\") {\n        throw new Error(\"Could not find 'name' of key in key URL\");\n      }\n\n      if (!parsed.vaultUrl || parsed.vaultUrl === \"\") {\n        throw new Error(\"Could not find 'vaultUrl' of key in key URL\");\n      }\n\n      this.vaultUrl = parsed.vaultUrl;\n      this.name = parsed.name;\n      this.version = parsed.version ?? \"\";\n    } catch (err: any) {\n      logger.error(err);\n\n      throw new Error(`${keyId} is not a valid Key Vault key ID`);\n    }\n  }\n\n  // The remote client supports all algorithms and all operations.\n  isSupported(_algorithm: string, _operation: CryptographyProviderOperation): boolean {\n    return true;\n  }\n\n  encrypt(\n    encryptParameters: EncryptParameters,\n    options: EncryptOptions = {}\n  ): Promise<EncryptResult> {\n    const { algorithm, plaintext, ...params } = encryptParameters;\n    const requestOptions = { ...options, ...params };\n\n    return tracingClient.withSpan(\n      \"RemoteCryptographyProvider.encrypt\",\n      requestOptions,\n      async (updatedOptions) => {\n        const result = await this.client.encrypt(\n          this.vaultUrl,\n          this.name,\n          this.version,\n          algorithm,\n          plaintext,\n          updatedOptions\n        );\n\n        return {\n          algorithm: encryptParameters.algorithm,\n          result: result.result!,\n          keyID: this.getKeyID(),\n          additionalAuthenticatedData: result.additionalAuthenticatedData,\n          authenticationTag: result.authenticationTag,\n          iv: result.iv,\n        };\n      }\n    );\n  }\n\n  decrypt(\n    decryptParameters: DecryptParameters,\n    options: DecryptOptions = {}\n  ): Promise<DecryptResult> {\n    const { algorithm, ciphertext, ...params } = decryptParameters;\n    const requestOptions = { ...options, ...params };\n\n    return tracingClient.withSpan(\n      \"RemoteCryptographyProvider.decrypt\",\n      requestOptions,\n      async (updatedOptions) => {\n        const result = await this.client.decrypt(\n          this.vaultUrl,\n          this.name,\n          this.version,\n          algorithm,\n          ciphertext,\n          updatedOptions\n        );\n        return {\n          result: result.result!,\n          keyID: this.getKeyID(),\n          algorithm,\n        };\n      }\n    );\n  }\n\n  wrapKey(\n    algorithm: KeyWrapAlgorithm,\n    keyToWrap: Uint8Array,\n    options: WrapKeyOptions = {}\n  ): Promise<WrapResult> {\n    return tracingClient.withSpan(\n      \"RemoteCryptographyProvider.wrapKey\",\n      options,\n      async (updatedOptions) => {\n        const result = await this.client.wrapKey(\n          this.vaultUrl,\n          this.name,\n          this.version,\n          algorithm,\n          keyToWrap,\n          updatedOptions\n        );\n\n        return {\n          result: result.result!,\n          algorithm,\n          keyID: this.getKeyID(),\n        };\n      }\n    );\n  }\n\n  unwrapKey(\n    algorithm: KeyWrapAlgorithm,\n    encryptedKey: Uint8Array,\n    options: UnwrapKeyOptions = {}\n  ): Promise<UnwrapResult> {\n    return tracingClient.withSpan(\n      \"RemoteCryptographyProvider.unwrapKey\",\n      options,\n      async (updatedOptions) => {\n        const result = await this.client.unwrapKey(\n          this.vaultUrl,\n          this.name,\n          this.version,\n          algorithm,\n          encryptedKey,\n          updatedOptions\n        );\n\n        return {\n          result: result.result!,\n          algorithm,\n          keyID: this.getKeyID(),\n        };\n      }\n    );\n  }\n\n  sign(algorithm: string, digest: Uint8Array, options: SignOptions = {}): Promise<SignResult> {\n    return tracingClient.withSpan(\n      \"RemoteCryptographyProvider.sign\",\n      options,\n      async (updatedOptions) => {\n        const result = await this.client.sign(\n          this.vaultUrl,\n          this.name,\n          this.version,\n          algorithm,\n          digest,\n          updatedOptions\n        );\n\n        return { result: result.result!, algorithm, keyID: this.getKeyID() };\n      }\n    );\n  }\n\n  verifyData(\n    algorithm: string,\n    data: Uint8Array,\n    signature: Uint8Array,\n    options: VerifyOptions = {}\n  ): Promise<VerifyResult> {\n    return tracingClient.withSpan(\n      \"RemoteCryptographyProvider.verifyData\",\n      options,\n      async (updatedOptions) => {\n        const hash = await createHash(algorithm, data);\n        return this.verify(algorithm, hash, signature, updatedOptions);\n      }\n    );\n  }\n\n  verify(\n    algorithm: string,\n    digest: Uint8Array,\n    signature: Uint8Array,\n    options: VerifyOptions = {}\n  ): Promise<VerifyResult> {\n    return tracingClient.withSpan(\n      \"RemoteCryptographyProvider.verify\",\n      options,\n      async (updatedOptions) => {\n        const response = await this.client.verify(\n          this.vaultUrl,\n          this.name,\n          this.version,\n          algorithm,\n          digest,\n          signature,\n          updatedOptions\n        );\n        return {\n          result: response.value ? response.value : false,\n          keyID: this.getKeyID(),\n        };\n      }\n    );\n  }\n\n  signData(algorithm: string, data: Uint8Array, options: SignOptions = {}): Promise<SignResult> {\n    return tracingClient.withSpan(\n      \"RemoteCryptographyProvider.signData\",\n      options,\n      async (updatedOptions) => {\n        const digest = await createHash(algorithm, data);\n        const result = await this.client.sign(\n          this.vaultUrl,\n          this.name,\n          this.version,\n          algorithm,\n          digest,\n          updatedOptions\n        );\n        return { result: result.result!, algorithm, keyID: this.getKeyID() };\n      }\n    );\n  }\n\n  /**\n   * The base URL to the vault.\n   */\n  readonly vaultUrl: string;\n\n  /**\n   * The ID of the key used to perform cryptographic operations for the client.\n   */\n  get keyId(): string | undefined {\n    return this.getKeyID();\n  }\n\n  /**\n   * Gets the {@link KeyVaultKey} used for cryptography operations, fetching it\n   * from KeyVault if necessary.\n   * @param options - Additional options.\n   */\n  getKey(options: GetKeyOptions = {}): Promise<KeyVaultKey> {\n    return tracingClient.withSpan(\n      \"RemoteCryptographyProvider.getKey\",\n      options,\n      async (updatedOptions) => {\n        if (typeof this.key === \"string\") {\n          if (!this.name || this.name === \"\") {\n            throw new Error(\"getKey requires a key with a name\");\n          }\n          const response = await this.client.getKey(\n            this.vaultUrl,\n            this.name,\n            options && options.version ? options.version : this.version ? this.version : \"\",\n            updatedOptions\n          );\n          this.key = getKeyFromKeyBundle(response);\n        }\n        return this.key;\n      }\n    );\n  }\n\n  /**\n   * A reference to the auto-generated KeyVault HTTP client.\n   */\n  private client: KeyVaultClient;\n\n  /**\n   * A reference to the key used for the cryptographic operations.\n   * Based on what was provided to the CryptographyClient constructor,\n   * it can be either a string with the URL of a Key Vault Key, or an already parsed {@link KeyVaultKey}.\n   */\n  private key: string | KeyVaultKey;\n\n  /**\n   * Name of the key the client represents\n   */\n  private name: string;\n\n  /**\n   * Version of the key the client represents\n   */\n  private version: string;\n\n  /**\n   * Attempts to retrieve the ID of the key.\n   */\n  private getKeyID(): string | undefined {\n    let kid;\n    if (typeof this.key !== \"string\") {\n      kid = this.key.id;\n    } else {\n      kid = this.key;\n    }\n\n    return kid;\n  }\n}\n\n/**\n * A helper method to either get the passed down generated client or initialize a new one.\n * An already constructed generated client may be passed down from {@link KeyClient} in which case we should reuse it.\n *\n * @internal\n * @param credential - The credential to use when initializing a new client.\n * @param options - The options for constructing a client or the underlying client if one already exists.\n * @returns - A generated client instance\n */\nfunction getOrInitializeClient(\n  credential: TokenCredential,\n  options: CryptographyClientOptions & { generatedClient?: KeyVaultClient }\n): KeyVaultClient {\n  if (options.generatedClient) {\n    return options.generatedClient;\n  }\n\n  const libInfo = `azsdk-js-keyvault-keys/${SDK_VERSION}`;\n\n  const userAgentOptions = options.userAgentOptions;\n\n  options.userAgentOptions = {\n    userAgentPrefix:\n      userAgentOptions && userAgentOptions.userAgentPrefix\n        ? `${userAgentOptions.userAgentPrefix} ${libInfo}`\n        : libInfo,\n  };\n\n  const authPolicy = bearerTokenAuthenticationPolicy({\n    credential,\n    scopes: [], // Scopes are going to be defined by the challenge callbacks.\n    challengeCallbacks: createKeyVaultChallengeCallbacks(options),\n  });\n\n  const internalPipelineOptions = {\n    ...options,\n    loggingOptions: {\n      logger: logger.info,\n      allowedHeaderNames: [\n        \"x-ms-keyvault-region\",\n        \"x-ms-keyvault-network-info\",\n        \"x-ms-keyvault-service-version\",\n      ],\n    },\n  };\n\n  const client = new KeyVaultClient(\n    options.serviceVersion || LATEST_API_VERSION,\n    internalPipelineOptions\n  );\n  client.pipeline.addPolicy(authPolicy);\n\n  return client;\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { JsonWebKey } from \"../keysModels\";\n\n/**\n * @internal\n * Encodes a length of a packet in DER format\n */\nfunction encodeLength(length: number): Uint8Array {\n  if (length <= 127) {\n    return Uint8Array.of(length);\n  } else if (length < 256) {\n    return Uint8Array.of(0x81, length);\n  } else if (length < 65536) {\n    return Uint8Array.of(0x82, length >> 8, length & 0xff);\n  } else {\n    throw new Error(\"Unsupported length to encode\");\n  }\n}\n\n/**\n * @internal\n * Encodes a buffer for DER, as sets the id to the given id\n */\nfunction encodeBuffer(buffer: Uint8Array, bufferId: number): Uint8Array {\n  if (buffer.length === 0) {\n    return buffer;\n  }\n\n  let result = new Uint8Array(buffer);\n\n  // If the high bit is set, prepend a 0\n  if (result[0] & 0x80) {\n    const array = new Uint8Array(result.length + 1);\n    array[0] = 0;\n    array.set(result, 1);\n    result = array;\n  }\n\n  // Prepend the DER header for this buffer\n  const encodedLength = encodeLength(result.length);\n  const totalLength = 1 + encodedLength.length + result.length;\n\n  const outputBuffer = new Uint8Array(totalLength);\n  outputBuffer[0] = bufferId;\n  outputBuffer.set(encodedLength, 1);\n  outputBuffer.set(result, 1 + encodedLength.length);\n\n  return outputBuffer;\n}\n\nfunction makeSequence(encodedParts: Uint8Array[]): string {\n  const totalLength = encodedParts.reduce((sum, part) => sum + part.length, 0);\n  const sequence = new Uint8Array(totalLength);\n\n  for (let i = 0; i < encodedParts.length; i++) {\n    const previousLength = i > 0 ? encodedParts[i - 1].length : 0;\n    sequence.set(encodedParts[i], previousLength);\n  }\n\n  const full_encoded = encodeBuffer(sequence, 0x30); // SEQUENCE\n  return Buffer.from(full_encoded).toString(\"base64\");\n}\n\n/**\n * Fill in the PEM with 64 character lines as per RFC:\n *\n * \"To represent the encapsulated text of a PEM message, the encoding\n * function's output is delimited into text lines (using local\n * conventions), with each line except the last containing exactly 64\n * printable characters and the final line containing 64 or fewer\n * printable characters.\"\n */\nfunction formatBase64Sequence(base64Sequence: string): string {\n  const lines = base64Sequence.match(/.{1,64}/g);\n  let result = \"\";\n  if (lines) {\n    for (const line of lines) {\n      result += line;\n      result += \"\\n\";\n    }\n  } else {\n    throw new Error(\"Could not create correct PEM\");\n  }\n  return result;\n}\n\n/**\n * @internal\n * Encode a JWK to PEM format. To do so, it internally repackages the JWK as a DER\n * that is then encoded as a PEM.\n */\nexport function convertJWKtoPEM(key: JsonWebKey): string {\n  let result = \"\";\n\n  if (key.n && key.e) {\n    const parts = [key.n, key.e];\n    const encodedParts = parts.map((part) => encodeBuffer(part, 0x2)); // INTEGER\n    const base64Sequence = makeSequence(encodedParts);\n    result += \"-----BEGIN RSA PUBLIC KEY-----\\n\";\n    result += formatBase64Sequence(base64Sequence);\n    result += \"-----END RSA PUBLIC KEY-----\\n\";\n  }\n\n  if (!result.length) {\n    throw new Error(\"Unsupported key format for local operations\");\n  }\n\n  return result.slice(0, -1); // Removing the last new line\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { OperationOptions } from \"@azure/core-client\";\nimport {\n  DecryptOptions,\n  DecryptParameters,\n  DecryptResult,\n  EncryptOptions,\n  EncryptParameters,\n  EncryptResult,\n  KeyWrapAlgorithm,\n  SignOptions,\n  SignResult,\n  SignatureAlgorithm,\n  UnwrapKeyOptions,\n  UnwrapResult,\n  VerifyOptions,\n  VerifyResult,\n  WrapKeyOptions,\n  WrapResult,\n} from \"..\";\n\nexport class LocalCryptographyUnsupportedError extends Error {}\n\n/**\n * The set of operations a {@link CryptographyProvider} supports.\n *\n * This corresponds to every single method on the interface so that providers\n * can declare whether they support this method or not.\n *\n * Purposely more granular than {@link KnownKeyOperations} because some providers\n * support verifyData but not verify.\n * @internal\n */\nexport type CryptographyProviderOperation =\n  | \"encrypt\"\n  | \"decrypt\"\n  | \"wrapKey\"\n  | \"unwrapKey\"\n  | \"sign\"\n  | \"signData\"\n  | \"verify\"\n  | \"verifyData\";\n\n/**\n *\n * Represents an object that can perform cryptography operations.\n * @internal\n */\nexport interface CryptographyProvider {\n  /**\n   * Encrypts the given plaintext with the specified encryption parameters.\n   * @internal\n   *\n   * @param encryptParameters - The encryption parameters, keyed on the encryption algorithm chosen.\n   * @param options - Additional options.\n   */\n  encrypt(encryptParameters: EncryptParameters, options?: EncryptOptions): Promise<EncryptResult>;\n\n  /**\n   * Decrypts the given ciphertext with the specified decryption parameters.\n   * @internal\n   *\n   * @param decryptParameters - The decryption parameters.\n   * @param options - Additional options.\n   */\n  decrypt(decryptParameters: DecryptParameters, options?: DecryptOptions): Promise<DecryptResult>;\n\n  /**\n   *\n   * @param algorithm - The algorithm to check support for.\n   * @param operation - The {@link CryptographyProviderOperation} to check support for.\n   */\n  isSupported(algorithm: string, operation: CryptographyProviderOperation): boolean;\n\n  /**\n   * Wraps the given key using the specified cryptography algorithm\n   * @internal\n   *\n   * @param algorithm - The encryption algorithm to use to wrap the given key.\n   * @param keyToWrap - The key to wrap.\n   * @param options - Additional options.\n   */\n  wrapKey(\n    algorithm: KeyWrapAlgorithm,\n    keyToWrap: Uint8Array,\n    options?: WrapKeyOptions\n  ): Promise<WrapResult>;\n\n  /**\n   * Unwraps the given wrapped key using the specified cryptography algorithm\n   * @internal\n   *\n   * @param algorithm - The decryption algorithm to use to unwrap the key.\n   * @param encryptedKey - The encrypted key to unwrap.\n   * @param options - Additional options.\n   */\n  unwrapKey(\n    algorithm: KeyWrapAlgorithm,\n    encryptedKey: Uint8Array,\n    options?: UnwrapKeyOptions\n  ): Promise<UnwrapResult>;\n\n  /**\n   * Cryptographically sign the digest of a message\n   * @internal\n   *\n   * @param algorithm - The signing algorithm to use.\n   * @param digest - The digest of the data to sign.\n   * @param options - Additional options.\n   */\n  sign(\n    algorithm: SignatureAlgorithm,\n    digest: Uint8Array,\n    options?: SignOptions\n  ): Promise<SignResult>;\n\n  /**\n   * Cryptographically sign a block of data\n   * @internal\n   *\n   * @param algorithm - The signing algorithm to use.\n   * @param data - The data to sign.\n   * @param options - Additional options.\n   */\n  signData(\n    algorithm: SignatureAlgorithm,\n    data: Uint8Array,\n    options?: SignOptions\n  ): Promise<SignResult>;\n\n  /**\n   * Verify the signed message digest\n   * @internal\n   *\n   * @param algorithm - The signing algorithm to use to verify with.\n   * @param digest - The digest to verify.\n   * @param signature - The signature to verify the digest against.\n   * @param options - Additional options.\n   */\n  verify(\n    algorithm: SignatureAlgorithm,\n    digest: Uint8Array,\n    signature: Uint8Array,\n    options?: VerifyOptions\n  ): Promise<VerifyResult>;\n\n  /**\n   * Verify the signed block of data\n   * @internal\n   *\n   * @param algorithm - The algorithm to use to verify with.\n   * @param data - The signed block of data to verify.\n   * @param signature - The signature to verify the block against.\n   * @param updatedOptions - Additional options.\n   */\n  verifyData(\n    algorithm: string,\n    data: Uint8Array,\n    signature: Uint8Array,\n    updatedOptions: OperationOptions\n  ): Promise<VerifyResult>;\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { RSA_PKCS1_OAEP_PADDING, RSA_PKCS1_PADDING } from \"constants\";\nimport { publicEncrypt } from \"crypto\";\nimport { createVerify } from \"./crypto\";\nimport {\n  DecryptOptions,\n  DecryptParameters,\n  DecryptResult,\n  EncryptOptions,\n  EncryptParameters,\n  EncryptResult,\n  JsonWebKey,\n  KeyWrapAlgorithm,\n  SignOptions,\n  SignResult,\n  SignatureAlgorithm,\n  UnwrapKeyOptions,\n  UnwrapResult,\n  VerifyOptions,\n  VerifyResult,\n  WrapKeyOptions,\n  WrapResult,\n} from \"..\";\nimport { convertJWKtoPEM } from \"./conversions\";\nimport {\n  CryptographyProvider,\n  CryptographyProviderOperation,\n  LocalCryptographyUnsupportedError,\n} from \"./models\";\n\n/**\n * An RSA cryptography provider supporting RSA algorithms.\n */\nexport class RsaCryptographyProvider implements CryptographyProvider {\n  constructor(key: JsonWebKey) {\n    this.key = key;\n  }\n\n  isSupported(algorithm: string, operation: CryptographyProviderOperation): boolean {\n    return (\n      this.applicableAlgorithms.includes(algorithm) && this.applicableOperations.includes(operation)\n    );\n  }\n\n  encrypt(encryptParameters: EncryptParameters, _options?: EncryptOptions): Promise<EncryptResult> {\n    this.ensureValid();\n    const keyPEM = convertJWKtoPEM(this.key);\n\n    const padding =\n      encryptParameters.algorithm === \"RSA1_5\" ? RSA_PKCS1_PADDING : RSA_PKCS1_OAEP_PADDING;\n\n    return Promise.resolve({\n      algorithm: encryptParameters.algorithm,\n      keyID: this.key.kid,\n      result: publicEncrypt(\n        { key: keyPEM, padding: padding },\n        Buffer.from(encryptParameters.plaintext)\n      ),\n    });\n  }\n\n  decrypt(\n    _decryptParameters: DecryptParameters,\n    _options?: DecryptOptions\n  ): Promise<DecryptResult> {\n    throw new LocalCryptographyUnsupportedError(\n      \"Decrypting using a local JsonWebKey is not supported.\"\n    );\n  }\n\n  wrapKey(\n    algorithm: KeyWrapAlgorithm,\n    keyToWrap: Uint8Array,\n    _options?: WrapKeyOptions\n  ): Promise<WrapResult> {\n    this.ensureValid();\n    const keyPEM = convertJWKtoPEM(this.key);\n\n    const padding = algorithm === \"RSA1_5\" ? RSA_PKCS1_PADDING : RSA_PKCS1_OAEP_PADDING;\n\n    return Promise.resolve({\n      algorithm: algorithm as KeyWrapAlgorithm,\n      result: publicEncrypt({ key: keyPEM, padding }, Buffer.from(keyToWrap)),\n      keyID: this.key.kid,\n    });\n  }\n\n  unwrapKey(\n    _algorithm: KeyWrapAlgorithm,\n    _encryptedKey: Uint8Array,\n    _options?: UnwrapKeyOptions\n  ): Promise<UnwrapResult> {\n    throw new LocalCryptographyUnsupportedError(\n      \"Unwrapping a key using a local JsonWebKey is not supported.\"\n    );\n  }\n\n  sign(\n    _algorithm: SignatureAlgorithm,\n    _digest: Uint8Array,\n    _options?: SignOptions\n  ): Promise<SignResult> {\n    throw new LocalCryptographyUnsupportedError(\n      \"Signing a digest using a local JsonWebKey is not supported.\"\n    );\n  }\n\n  signData(\n    _algorithm: SignatureAlgorithm,\n    _data: Uint8Array,\n    _options?: SignOptions\n  ): Promise<SignResult> {\n    throw new LocalCryptographyUnsupportedError(\n      \"Signing a block of data using a local JsonWebKey is not supported.\"\n    );\n  }\n\n  async verify(\n    _algorithm: SignatureAlgorithm,\n    _digest: Uint8Array,\n    _signature: Uint8Array,\n    _options?: VerifyOptions\n  ): Promise<VerifyResult> {\n    throw new LocalCryptographyUnsupportedError(\n      \"Verifying a digest using a local JsonWebKey is not supported.\"\n    );\n  }\n\n  verifyData(\n    algorithm: SignatureAlgorithm,\n    data: Uint8Array,\n    signature: Uint8Array,\n    _options?: VerifyOptions\n  ): Promise<VerifyResult> {\n    this.ensureValid();\n    const keyPEM = convertJWKtoPEM(this.key);\n\n    const verifier = createVerify(algorithm, data);\n    return Promise.resolve({\n      result: verifier.verify(keyPEM, Buffer.from(signature)),\n      keyID: this.key.kid,\n    });\n  }\n\n  /**\n   * The {@link JsonWebKey} used to perform crypto operations.\n   */\n  private key: JsonWebKey;\n\n  /**\n   * The set of algorithms this provider supports\n   */\n  private applicableAlgorithms: string[] = [\n    \"RSA1_5\",\n    \"RSA-OAEP\",\n    \"PS256\",\n    \"RS256\",\n    \"PS384\",\n    \"RS384\",\n    \"PS512\",\n    \"RS512\",\n  ];\n\n  /**\n   * The set of operations this provider supports\n   */\n  private applicableOperations: CryptographyProviderOperation[] = [\n    \"encrypt\",\n    \"wrapKey\",\n    \"verifyData\",\n  ];\n\n  /**\n   * Mapping between signature algorithms and their corresponding hash algorithms. Externally used for testing.\n   * @internal\n   */\n  signatureAlgorithmToHashAlgorithm: { [s: string]: string } = {\n    PS256: \"SHA256\",\n    RS256: \"SHA256\",\n    PS384: \"SHA384\",\n    RS384: \"SHA384\",\n    PS512: \"SHA512\",\n    RS512: \"SHA512\",\n  };\n\n  private ensureValid(): void {\n    if (\n      this.key &&\n      this.key.kty?.toUpperCase() !== \"RSA\" &&\n      this.key.kty?.toUpperCase() !== \"RSA-HSM\"\n    ) {\n      throw new Error(\"Key type does not match the algorithm RSA\");\n    }\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { OperationOptions } from \"@azure/core-client\";\nimport * as crypto from \"crypto\";\nimport {\n  AesCbcEncryptParameters,\n  DecryptOptions,\n  DecryptResult,\n  EncryptOptions,\n  EncryptResult,\n  JsonWebKey,\n  KeyWrapAlgorithm,\n  SignOptions,\n  SignResult,\n  UnwrapKeyOptions,\n  UnwrapResult,\n  VerifyOptions,\n  VerifyResult,\n  WrapKeyOptions,\n  WrapResult,\n} from \"..\";\nimport { AesCbcDecryptParameters } from \"../cryptographyClientModels\";\nimport {\n  CryptographyProvider,\n  CryptographyProviderOperation,\n  LocalCryptographyUnsupportedError,\n} from \"./models\";\n\n/**\n * An AES cryptography provider supporting AES algorithms.\n * @internal\n */\nexport class AesCryptographyProvider implements CryptographyProvider {\n  private key: JsonWebKey;\n  constructor(key: JsonWebKey) {\n    this.key = key;\n  }\n  encrypt(\n    encryptParameters: AesCbcEncryptParameters,\n    _options?: EncryptOptions\n  ): Promise<EncryptResult> {\n    const { algorithm, keySizeInBytes } = this.supportedAlgorithms[encryptParameters.algorithm];\n    const iv = encryptParameters.iv || crypto.randomBytes(16);\n\n    this.ensureValid(keySizeInBytes);\n\n    const cipher = crypto.createCipheriv(algorithm, this.key.k!.subarray(0, keySizeInBytes), iv);\n    let encrypted = cipher.update(Buffer.from(encryptParameters.plaintext));\n    encrypted = Buffer.concat([encrypted, cipher.final()]);\n\n    return Promise.resolve({\n      algorithm: encryptParameters.algorithm,\n      result: encrypted,\n      iv: iv,\n    });\n  }\n\n  decrypt(\n    decryptParameters: AesCbcDecryptParameters,\n    _options?: DecryptOptions\n  ): Promise<DecryptResult> {\n    const { algorithm, keySizeInBytes } = this.supportedAlgorithms[decryptParameters.algorithm];\n\n    this.ensureValid(keySizeInBytes);\n\n    const decipher = crypto.createDecipheriv(\n      algorithm,\n      this.key.k!.subarray(0, keySizeInBytes),\n      decryptParameters.iv\n    );\n    let dec = decipher.update(Buffer.from(decryptParameters.ciphertext));\n    dec = Buffer.concat([dec, decipher.final()]);\n\n    return Promise.resolve({\n      algorithm: decryptParameters.algorithm,\n      result: dec,\n    });\n  }\n\n  isSupported(algorithm: string, operation: CryptographyProviderOperation): boolean {\n    if (!this.key.k) {\n      return false;\n    }\n\n    if (!Object.keys(this.supportedAlgorithms).includes(algorithm)) {\n      return false;\n    }\n\n    if (!this.supportedOperations.includes(operation)) {\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * The set of algorithms this provider supports.\n   * For AES encryption, the values include the underlying algorithm used in crypto\n   * as well as the key size in bytes.\n   *\n   * We start with support for A[SIZE]CBCPAD which uses the PKCS padding (the default padding scheme in node crypto)\n   */\n  private supportedAlgorithms: { [s: string]: { algorithm: string; keySizeInBytes: number } } = {\n    A128CBCPAD: {\n      algorithm: \"aes-128-cbc\",\n      keySizeInBytes: 128 >> 3,\n    },\n    A192CBCPAD: {\n      algorithm: \"aes-192-cbc\",\n      keySizeInBytes: 192 >> 3,\n    },\n    A256CBCPAD: {\n      algorithm: \"aes-256-cbc\",\n      keySizeInBytes: 256 >> 3,\n    },\n  };\n\n  private supportedOperations: CryptographyProviderOperation[] = [\"encrypt\", \"decrypt\"];\n\n  wrapKey(\n    _algorithm: KeyWrapAlgorithm,\n    _keyToWrap: Uint8Array,\n    _options?: WrapKeyOptions\n  ): Promise<WrapResult> {\n    throw new LocalCryptographyUnsupportedError(\n      \"Wrapping a key using a local JsonWebKey is not supported for AES.\"\n    );\n  }\n\n  unwrapKey(\n    _algorithm: KeyWrapAlgorithm,\n    _encryptedKey: Uint8Array,\n    _options?: UnwrapKeyOptions\n  ): Promise<UnwrapResult> {\n    throw new LocalCryptographyUnsupportedError(\n      \"Unwrapping a key using a local JsonWebKey is not supported for AES.\"\n    );\n  }\n\n  sign(_algorithm: string, _digest: Uint8Array, _options?: SignOptions): Promise<SignResult> {\n    throw new LocalCryptographyUnsupportedError(\n      \"Signing using a local JsonWebKey is not supported for AES.\"\n    );\n  }\n\n  signData(_algorithm: string, _data: Uint8Array, _options?: SignOptions): Promise<SignResult> {\n    throw new LocalCryptographyUnsupportedError(\n      \"Signing using a local JsonWebKey is not supported for AES.\"\n    );\n  }\n\n  verify(\n    _algorithm: string,\n    _digest: Uint8Array,\n    _signature: Uint8Array,\n    _options?: VerifyOptions\n  ): Promise<VerifyResult> {\n    throw new LocalCryptographyUnsupportedError(\n      \"Verifying using a local JsonWebKey is not supported for AES.\"\n    );\n  }\n  verifyData(\n    _algorithm: string,\n    _data: Uint8Array,\n    _signature: Uint8Array,\n    _updatedOptions: OperationOptions\n  ): Promise<VerifyResult> {\n    throw new LocalCryptographyUnsupportedError(\n      \"Verifying using a local JsonWebKey is not supported for AES.\"\n    );\n  }\n\n  private ensureValid(keySizeInBytes: number): void {\n    if (\n      this.key &&\n      this.key.kty?.toUpperCase() !== \"OCT\" &&\n      this.key.kty?.toUpperCase() !== \"OCT-HSM\"\n    ) {\n      throw new Error(\"Key type does not match the key type oct or oct-hsm\");\n    }\n\n    if (!this.key.k) {\n      throw new Error(\"Symmetric key is required\");\n    }\n\n    if (this.key.k.length < keySizeInBytes) {\n      throw new Error(`Key must be at least ${keySizeInBytes << 3} bits`);\n    }\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { OperationOptions } from \"@azure/core-client\";\nimport { TokenCredential } from \"@azure/core-auth\";\nimport {\n  CryptographyClientOptions,\n  GetKeyOptions,\n  JsonWebKey,\n  KeyOperation,\n  KeyVaultKey,\n  KnownKeyOperations,\n} from \"./keysModels\";\nimport {\n  AesCbcEncryptParameters,\n  AesCbcEncryptionAlgorithm,\n  CryptographyClientKey,\n  DecryptOptions,\n  DecryptParameters,\n  DecryptResult,\n  EncryptOptions,\n  EncryptParameters,\n  EncryptResult,\n  EncryptionAlgorithm,\n  KeyWrapAlgorithm,\n  SignOptions,\n  SignResult,\n  SignatureAlgorithm,\n  UnwrapKeyOptions,\n  UnwrapResult,\n  VerifyOptions,\n  VerifyResult,\n  WrapKeyOptions,\n  WrapResult,\n} from \"./cryptographyClientModels\";\nimport { RemoteCryptographyProvider } from \"./cryptography/remoteCryptographyProvider\";\nimport { randomBytes } from \"./cryptography/crypto\";\nimport { CryptographyProvider, CryptographyProviderOperation } from \"./cryptography/models\";\nimport { RsaCryptographyProvider } from \"./cryptography/rsaCryptographyProvider\";\nimport { AesCryptographyProvider } from \"./cryptography/aesCryptographyProvider\";\nimport { tracingClient } from \"./tracing\";\n\n/**\n * A client used to perform cryptographic operations on an Azure Key vault key\n * or a local {@link JsonWebKey}.\n */\nexport class CryptographyClient {\n  /**\n   * The key the CryptographyClient currently holds.\n   */\n  private key: CryptographyClientKey;\n\n  /**\n   * The remote provider, which would be undefined if used in local mode.\n   */\n  private remoteProvider?: RemoteCryptographyProvider;\n\n  /**\n   * Constructs a new instance of the Cryptography client for the given key\n   *\n   * Example usage:\n   * ```ts\n   * import { KeyClient, CryptographyClient } from \"@azure/keyvault-keys\";\n   * import { DefaultAzureCredential } from \"@azure/identity\";\n   *\n   * let vaultUrl = `https://<MY KEYVAULT HERE>.vault.azure.net`;\n   * let credentials = new DefaultAzureCredential();\n   *\n   * let keyClient = new KeyClient(vaultUrl, credentials);\n   * let keyVaultKey = await keyClient.getKey(\"MyKey\");\n   *\n   * let client = new CryptographyClient(keyVaultKey.id, credentials);\n   * // or\n   * let client = new CryptographyClient(keyVaultKey, credentials);\n   * ```\n   * @param key - The key to use during cryptography tasks. You can also pass the identifier of the key i.e its url here.\n   * @param credential - An object that implements the `TokenCredential` interface used to authenticate requests to the service. Use the \\@azure/identity package to create a credential that suits your needs.\n   * @param pipelineOptions - Pipeline options used to configure Key Vault API requests.\n   *                          Omit this parameter to use the default pipeline configuration.\n   */\n  constructor(\n    key: string | KeyVaultKey,\n    credential: TokenCredential,\n    pipelineOptions?: CryptographyClientOptions\n  );\n  /**\n   * Constructs a new instance of the Cryptography client for the given key in local mode.\n   *\n   * Example usage:\n   * ```ts\n   * import { CryptographyClient } from \"@azure/keyvault-keys\";\n   *\n   * const jsonWebKey: JsonWebKey = {\n   *   // ...\n   * };\n   * const client = new CryptographyClient(jsonWebKey);\n   * ```\n   * @param key - The JsonWebKey to use during cryptography operations.\n   */\n  constructor(key: JsonWebKey);\n  /**\n   * Internal constructor implementation for either local or Key Vault backed keys.\n   * @param key - The key to use during cryptography tasks.\n   * @param credential - Teh credential to use when constructing a Key Vault Cryptography client.\n   */\n  constructor(\n    key: string | KeyVaultKey | JsonWebKey,\n    credential?: TokenCredential,\n    pipelineOptions: CryptographyClientOptions = {}\n  ) {\n    if (typeof key === \"string\") {\n      // Key URL for remote-local operations.\n      this.key = {\n        kind: \"identifier\",\n        value: key,\n      };\n      this.remoteProvider = new RemoteCryptographyProvider(key, credential!, pipelineOptions);\n    } else if (\"name\" in key) {\n      // KeyVault key for remote-local operations.\n      this.key = {\n        kind: \"KeyVaultKey\",\n        value: key,\n      };\n      this.remoteProvider = new RemoteCryptographyProvider(key, credential!, pipelineOptions);\n    } else {\n      // JsonWebKey for local-only operations.\n      this.key = {\n        kind: \"JsonWebKey\",\n        value: key,\n      };\n    }\n  }\n\n  /**\n   * The base URL to the vault. If a local {@link JsonWebKey} is used vaultUrl will be empty.\n   */\n  get vaultUrl(): string {\n    return this.remoteProvider?.vaultUrl || \"\";\n  }\n\n  /**\n   * The ID of the key used to perform cryptographic operations for the client.\n   */\n  get keyID(): string | undefined {\n    if (this.key.kind === \"identifier\") {\n      return this.key.value;\n    } else if (this.key.kind === \"KeyVaultKey\") {\n      return this.key.value.id;\n    } else {\n      return this.key.value.kid;\n    }\n  }\n\n  /**\n   * Encrypts the given plaintext with the specified encryption parameters.\n   * Depending on the algorithm set in the encryption parameters, the set of possible encryption parameters will change.\n   *\n   * Example usage:\n   * ```ts\n   * let client = new CryptographyClient(keyVaultKey, credentials);\n   * let result = await client.encrypt({ algorithm: \"RSA1_5\", plaintext: Buffer.from(\"My Message\")});\n   * let result = await client.encrypt({ algorithm: \"A256GCM\", plaintext: Buffer.from(\"My Message\"), additionalAuthenticatedData: Buffer.from(\"My authenticated data\")});\n   * ```\n   * @param encryptParameters - The encryption parameters, keyed on the encryption algorithm chosen.\n   * @param options - Additional options.\n   */\n  public encrypt(\n    encryptParameters: EncryptParameters,\n    options?: EncryptOptions\n  ): Promise<EncryptResult>;\n  /**\n   * Encrypts the given plaintext with the specified cryptography algorithm\n   *\n   * Example usage:\n   * ```ts\n   * let client = new CryptographyClient(keyVaultKey, credentials);\n   * let result = await client.encrypt(\"RSA1_5\", Buffer.from(\"My Message\"));\n   * ```\n   * @param algorithm - The algorithm to use.\n   * @param plaintext - The text to encrypt.\n   * @param options - Additional options.\n   * @deprecated Use `encrypt({ algorithm, plaintext }, options)` instead.\n   */\n  public encrypt(\n    algorithm: EncryptionAlgorithm,\n    plaintext: Uint8Array,\n    options?: EncryptOptions\n  ): Promise<EncryptResult>;\n  public encrypt(\n    ...args:\n      | [EncryptParameters, EncryptOptions?]\n      | [EncryptionAlgorithm, Uint8Array, EncryptOptions?]\n  ): Promise<EncryptResult> {\n    const [parameters, options] = this.disambiguateEncryptArguments(args);\n    return tracingClient.withSpan(\"CryptographyClient.encrypt\", options, async (updatedOptions) => {\n      this.ensureValid(await this.fetchKey(updatedOptions), KnownKeyOperations.Encrypt);\n      this.initializeIV(parameters);\n      const provider = await this.getProvider(\"encrypt\", parameters.algorithm, updatedOptions);\n      try {\n        return provider.encrypt(parameters, updatedOptions);\n      } catch (error: any) {\n        if (this.remoteProvider) {\n          return this.remoteProvider.encrypt(parameters, updatedOptions);\n        }\n        throw error;\n      }\n    });\n  }\n\n  private initializeIV(parameters: EncryptParameters): void {\n    // For AES-GCM the service **must** generate the IV, so we only populate it for AES-CBC\n    const algorithmsRequiringIV: AesCbcEncryptionAlgorithm[] = [\n      \"A128CBC\",\n      \"A128CBCPAD\",\n      \"A192CBC\",\n      \"A192CBCPAD\",\n      \"A256CBC\",\n      \"A256CBCPAD\",\n    ];\n\n    if (parameters.algorithm in algorithmsRequiringIV) {\n      try {\n        const cbcParams = parameters as AesCbcEncryptParameters;\n        if (!cbcParams.iv) {\n          cbcParams.iv = randomBytes(16);\n        }\n      } catch (e: any) {\n        throw new Error(\n          `Unable to initialize IV for algorithm ${parameters.algorithm}. You may pass a valid IV to avoid this error. Error: ${e.message}`\n        );\n      }\n    }\n  }\n\n  /**\n   * Standardizes the arguments of multiple overloads into a single shape.\n   * @param args - The encrypt arguments\n   */\n  private disambiguateEncryptArguments(\n    args: [EncryptParameters, EncryptOptions?] | [string, Uint8Array, EncryptOptions?]\n  ): [EncryptParameters, EncryptOptions] {\n    if (typeof args[0] === \"string\") {\n      // Sample shape: [\"RSA1_5\", buffer, options]\n      return [\n        {\n          algorithm: args[0],\n          plaintext: args[1],\n        } as EncryptParameters,\n        args[2] || {},\n      ];\n    } else {\n      // Sample shape: [{ algorithm: \"RSA1_5\", plaintext: buffer }, options]\n      return [args[0], (args[1] || {}) as EncryptOptions];\n    }\n  }\n\n  /**\n   * Decrypts the given ciphertext with the specified decryption parameters.\n   * Depending on the algorithm used in the decryption parameters, the set of possible decryption parameters will change.\n   *\n   * Microsoft recommends you not use CBC without first ensuring the integrity of the ciphertext using, for example, an HMAC. See https://docs.microsoft.com/dotnet/standard/security/vulnerabilities-cbc-mode for more information.\n   *\n   * Example usage:\n   * ```ts\n   * let client = new CryptographyClient(keyVaultKey, credentials);\n   * let result = await client.decrypt({ algorithm: \"RSA1_5\", ciphertext: encryptedBuffer });\n   * let result = await client.decrypt({ algorithm: \"A256GCM\", iv: ivFromEncryptResult, authenticationTag: tagFromEncryptResult });\n   * ```\n   * @param decryptParameters - The decryption parameters.\n   * @param options - Additional options.\n   */\n  public async decrypt(\n    decryptParameters: DecryptParameters,\n    options?: DecryptOptions\n  ): Promise<DecryptResult>;\n  /**\n   * Decrypts the given ciphertext with the specified cryptography algorithm\n   *\n   * Example usage:\n   * ```ts\n   * let client = new CryptographyClient(keyVaultKey, credentials);\n   * let result = await client.decrypt(\"RSA1_5\", encryptedBuffer);\n   * ```\n   *\n   * Microsoft recommends you not use CBC without first ensuring the integrity of the ciphertext using, for example, an HMAC. See https://docs.microsoft.com/dotnet/standard/security/vulnerabilities-cbc-mode for more information.\n   *\n   * @param algorithm - The algorithm to use.\n   * @param ciphertext - The text to decrypt.\n   * @param options - Additional options.\n   * @deprecated Use `decrypt({ algorithm, ciphertext }, options)` instead.\n   */\n  public decrypt(\n    algorithm: EncryptionAlgorithm,\n    ciphertext: Uint8Array,\n    options?: DecryptOptions\n  ): Promise<DecryptResult>;\n  public decrypt(\n    ...args:\n      | [DecryptParameters, DecryptOptions?]\n      | [EncryptionAlgorithm, Uint8Array, DecryptOptions?]\n  ): Promise<DecryptResult> {\n    const [parameters, options] = this.disambiguateDecryptArguments(args);\n\n    return tracingClient.withSpan(\"CryptographyClient.decrypt\", options, async (updatedOptions) => {\n      this.ensureValid(await this.fetchKey(updatedOptions), KnownKeyOperations.Decrypt);\n      const provider = await this.getProvider(\"decrypt\", parameters.algorithm, updatedOptions);\n      try {\n        return provider.decrypt(parameters, updatedOptions);\n      } catch (error: any) {\n        if (this.remoteProvider) {\n          return this.remoteProvider.decrypt(parameters, updatedOptions);\n        }\n        throw error;\n      }\n    });\n  }\n\n  /**\n   * Standardizes the arguments of multiple overloads into a single shape.\n   * @param args - The decrypt arguments\n   */\n  private disambiguateDecryptArguments(\n    args: [DecryptParameters, DecryptOptions?] | [string, Uint8Array, DecryptOptions?]\n  ): [DecryptParameters, DecryptOptions] {\n    if (typeof args[0] === \"string\") {\n      // Sample shape: [\"RSA1_5\", encryptedBuffer, options]\n      return [\n        {\n          algorithm: args[0],\n          ciphertext: args[1],\n        } as DecryptParameters,\n        args[2] || {},\n      ];\n    } else {\n      // Sample shape: [{ algorithm: \"RSA1_5\", ciphertext: encryptedBuffer }, options]\n      return [args[0], (args[1] || {}) as DecryptOptions];\n    }\n  }\n\n  /**\n   * Wraps the given key using the specified cryptography algorithm\n   *\n   * Example usage:\n   * ```ts\n   * let client = new CryptographyClient(keyVaultKey, credentials);\n   * let result = await client.wrapKey(\"RSA1_5\", keyToWrap);\n   * ```\n   * @param algorithm - The encryption algorithm to use to wrap the given key.\n   * @param key - The key to wrap.\n   * @param options - Additional options.\n   */\n  public wrapKey(\n    algorithm: KeyWrapAlgorithm,\n    key: Uint8Array,\n    options: WrapKeyOptions = {}\n  ): Promise<WrapResult> {\n    return tracingClient.withSpan(\"CryptographyClient.wrapKey\", options, async (updatedOptions) => {\n      this.ensureValid(await this.fetchKey(updatedOptions), KnownKeyOperations.WrapKey);\n      const provider = await this.getProvider(\"wrapKey\", algorithm, updatedOptions);\n      try {\n        return provider.wrapKey(algorithm, key, updatedOptions);\n      } catch (err: any) {\n        if (this.remoteProvider) {\n          return this.remoteProvider.wrapKey(algorithm, key, options);\n        }\n        throw err;\n      }\n    });\n  }\n\n  /**\n   * Unwraps the given wrapped key using the specified cryptography algorithm\n   *\n   * Example usage:\n   * ```ts\n   * let client = new CryptographyClient(keyVaultKey, credentials);\n   * let result = await client.unwrapKey(\"RSA1_5\", keyToUnwrap);\n   * ```\n   * @param algorithm - The decryption algorithm to use to unwrap the key.\n   * @param encryptedKey - The encrypted key to unwrap.\n   * @param options - Additional options.\n   */\n  public unwrapKey(\n    algorithm: KeyWrapAlgorithm,\n    encryptedKey: Uint8Array,\n    options: UnwrapKeyOptions = {}\n  ): Promise<UnwrapResult> {\n    return tracingClient.withSpan(\n      \"CryptographyClient.unwrapKey\",\n      options,\n      async (updatedOptions) => {\n        this.ensureValid(await this.fetchKey(updatedOptions), KnownKeyOperations.UnwrapKey);\n        const provider = await this.getProvider(\"unwrapKey\", algorithm, updatedOptions);\n        try {\n          return provider.unwrapKey(algorithm, encryptedKey, updatedOptions);\n        } catch (err: any) {\n          if (this.remoteProvider) {\n            return this.remoteProvider.unwrapKey(algorithm, encryptedKey, options);\n          }\n          throw err;\n        }\n      }\n    );\n  }\n\n  /**\n   * Cryptographically sign the digest of a message\n   *\n   * Example usage:\n   * ```ts\n   * let client = new CryptographyClient(keyVaultKey, credentials);\n   * let result = await client.sign(\"RS256\", digest);\n   * ```\n   * @param algorithm - The signing algorithm to use.\n   * @param digest - The digest of the data to sign.\n   * @param options - Additional options.\n   */\n  public sign(\n    algorithm: SignatureAlgorithm,\n    digest: Uint8Array,\n    options: SignOptions = {}\n  ): Promise<SignResult> {\n    return tracingClient.withSpan(\"CryptographyClient.sign\", options, async (updatedOptions) => {\n      this.ensureValid(await this.fetchKey(updatedOptions), KnownKeyOperations.Sign);\n      const provider = await this.getProvider(\"sign\", algorithm, updatedOptions);\n      try {\n        return provider.sign(algorithm, digest, updatedOptions);\n      } catch (err: any) {\n        if (this.remoteProvider) {\n          return this.remoteProvider.sign(algorithm, digest, updatedOptions);\n        }\n        throw err;\n      }\n    });\n  }\n\n  /**\n   * Verify the signed message digest\n   *\n   * Example usage:\n   * ```ts\n   * let client = new CryptographyClient(keyVaultKey, credentials);\n   * let result = await client.verify(\"RS256\", signedDigest, signature);\n   * ```\n   * @param algorithm - The signing algorithm to use to verify with.\n   * @param digest - The digest to verify.\n   * @param signature - The signature to verify the digest against.\n   * @param options - Additional options.\n   */\n  public verify(\n    algorithm: SignatureAlgorithm,\n    digest: Uint8Array,\n    signature: Uint8Array,\n    options: VerifyOptions = {}\n  ): Promise<VerifyResult> {\n    return tracingClient.withSpan(\"CryptographyClient.verify\", options, async (updatedOptions) => {\n      this.ensureValid(await this.fetchKey(updatedOptions), KnownKeyOperations.Verify);\n      const provider = await this.getProvider(\"verify\", algorithm, updatedOptions);\n      try {\n        return provider.verify(algorithm, digest, signature, updatedOptions);\n      } catch (err: any) {\n        if (this.remoteProvider) {\n          return this.remoteProvider.verify(algorithm, digest, signature, updatedOptions);\n        }\n        throw err;\n      }\n    });\n  }\n\n  /**\n   * Cryptographically sign a block of data\n   *\n   * Example usage:\n   * ```ts\n   * let client = new CryptographyClient(keyVaultKey, credentials);\n   * let result = await client.signData(\"RS256\", message);\n   * ```\n   * @param algorithm - The signing algorithm to use.\n   * @param data - The data to sign.\n   * @param options - Additional options.\n   */\n  public signData(\n    algorithm: SignatureAlgorithm,\n    data: Uint8Array,\n    options: SignOptions = {}\n  ): Promise<SignResult> {\n    return tracingClient.withSpan(\n      \"CryptographyClient.signData\",\n      options,\n      async (updatedOptions) => {\n        this.ensureValid(await this.fetchKey(updatedOptions), KnownKeyOperations.Sign);\n        const provider = await this.getProvider(\"signData\", algorithm, updatedOptions);\n        try {\n          return provider.signData(algorithm, data, updatedOptions);\n        } catch (err: any) {\n          if (this.remoteProvider) {\n            return this.remoteProvider.signData(algorithm, data, options);\n          }\n          throw err;\n        }\n      }\n    );\n  }\n\n  /**\n   * Verify the signed block of data\n   *\n   * Example usage:\n   * ```ts\n   * let client = new CryptographyClient(keyVaultKey, credentials);\n   * let result = await client.verifyData(\"RS256\", signedMessage, signature);\n   * ```\n   * @param algorithm - The algorithm to use to verify with.\n   * @param data - The signed block of data to verify.\n   * @param signature - The signature to verify the block against.\n   * @param options - Additional options.\n   */\n  public verifyData(\n    algorithm: SignatureAlgorithm,\n    data: Uint8Array,\n    signature: Uint8Array,\n    options: VerifyOptions = {}\n  ): Promise<VerifyResult> {\n    return tracingClient.withSpan(\n      \"CryptographyClient.verifyData\",\n      options,\n      async (updatedOptions) => {\n        this.ensureValid(await this.fetchKey(updatedOptions), KnownKeyOperations.Verify);\n        const provider = await this.getProvider(\"verifyData\", algorithm, updatedOptions);\n        try {\n          return provider.verifyData(algorithm, data, signature, updatedOptions);\n        } catch (err: any) {\n          if (this.remoteProvider) {\n            return this.remoteProvider.verifyData(algorithm, data, signature, updatedOptions);\n          }\n          throw err;\n        }\n      }\n    );\n  }\n\n  /**\n   * Retrieves the {@link JsonWebKey} from the Key Vault.\n   *\n   * Example usage:\n   * ```ts\n   * let client = new CryptographyClient(keyVaultKey, credentials);\n   * let result = await client.getKeyMaterial();\n   * ```\n   */\n  private async getKeyMaterial(options: GetKeyOptions): Promise<JsonWebKey> {\n    const key = await this.fetchKey(options);\n\n    switch (key.kind) {\n      case \"JsonWebKey\":\n        return key.value;\n      case \"KeyVaultKey\":\n        return key.value.key!;\n      default:\n        throw new Error(\"Failed to exchange Key ID for an actual KeyVault Key.\");\n    }\n  }\n\n  /**\n   * Returns the underlying key used for cryptographic operations.\n   * If needed, fetches the key from KeyVault and exchanges the ID for the actual key.\n   * @param options - The additional options.\n   */\n  private async fetchKey<T extends OperationOptions>(options: T): Promise<CryptographyClientKey> {\n    if (this.key.kind === \"identifier\") {\n      // Exchange the identifier with the actual key when needed\n      const key = await this.remoteProvider!.getKey(options);\n      this.key = { kind: \"KeyVaultKey\", value: key };\n    }\n    return this.key;\n  }\n\n  private providers?: CryptographyProvider[];\n  /**\n   * Gets the provider that support this algorithm and operation.\n   * The available providers are ordered by priority such that the first provider that supports this\n   * operation is the one we should use.\n   * @param operation - The {@link KeyOperation}.\n   * @param algorithm - The algorithm to use.\n   */\n  private async getProvider<T extends OperationOptions>(\n    operation: CryptographyProviderOperation,\n    algorithm: string,\n    options: T\n  ): Promise<CryptographyProvider> {\n    if (!this.providers) {\n      const keyMaterial = await this.getKeyMaterial(options);\n      // Add local crypto providers as needed\n      this.providers = [\n        new RsaCryptographyProvider(keyMaterial),\n        new AesCryptographyProvider